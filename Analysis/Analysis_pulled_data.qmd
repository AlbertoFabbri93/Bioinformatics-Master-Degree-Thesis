---
title: "A study on brain metastases from primary breast cancer"
author: "Alberto Fabbri"
format: html
editor_options: 
  chunk_output_type: inline
---

# Brain metastaes from primary breast cancer

This study aims to investigate the immune microenvironment of brain metastases from primary breast cancer. The analysis is performed on NanoString data from 7 patients.

## Set up the environment

### Packages

This analysis uses `renv` to manage the dependencies. `renv` is a normal R package that can be installed with:

`install.packages("renv")`

Once `renv` is installed it can be used to install the necessary packages by running the following code:

`renv::restore()`

`renv` will then proceed to install all the packages specified in the `renv.lock` file.

**Do not update the version of the packages if not absolutely necessary.**

If some packages have been update, run `renv::snapshot()` to update the `renv.lock` file.

### Quarto

To run this file it is necessary to have `quarto` installed. `quarto` is a software used to create reproducible documents that embed code. It can be installed by downloading it from the official website:

[https://quarto.org]

::: {.content-hidden}
### Load the necessary packages
:::

```{r}
#| label: setup
#| include: false

# Work with single cell and spatial omics data
library("Seurat")

# The future package is not supported in Seurat v5
# # Do not import these future symbols because they conflict with the zeallot package
# library (future, exclude = c("%->%", "%<-%"));
# # Parallelize the computation with several worker processes that will run in their own R session
# plan("multisession", workers = 6)
# # Set the maximum size of the future globals
# options(future.globals.maxSize = 6.5 * 2^30)
# # Ensure proper random number seeding globally
# options(future.seed = TRUE)

###### TIDYVERSE ######
# Data manipulation
library("dplyr")
# Create nice plots
library("ggplot2")
# Open Excel files
library("readxl")
# Open CSV files
library("readr")
# Better dataframes
library("tibble")
# Pivot tibbles
library("tidyr")

# Unpack multiple values without temporary variables
library("zeallot")
# Add interpreted string literals
library("glue")
# Sane way to declare file paths
library("here")
# Machine learning library from NanoString
library("InSituType")
# Used for the barplots
library("dittoSeq")
# Used to visualize the raw images from AtoMx
library("EBImage")
# For faster estimation when using SCTransform
library("glmGamPoi")
# For fast Wilcoxon rank sum test
library("presto")
# Combine multidimensional arrays into a single array
library("abind")
# Sparse and dense matrix classes and methods
library("Matrix")
# Analysis of cell-cell communication
library("CellChat")

## PLOTTING
# Used to annotate images with multiple plots
library("patchwork")
# Used to arrange plots in a common grid
library("ggpubr")
# Extension of ggplot2 supporting relational data structures such as networks, graphs, and trees
library("ggraph")
# Used to plot the cluster tree created by running FindClusters at several resolutions
library("clustree")
# Add more layout options to ggplot
library("ggforce")
# More complex heatmaps
library("ComplexHeatmap")
# Additional color palettes
library("RColorBrewer")
library("pals")
library("circlize")

## GENE SET ENRICHMENT ANALYSIS
# Used to perform gene set enrichment analysis
library("clusterProfiler")
# Database with the gene information
library("org.Hs.eg.db")
# List all supported types
keytypes(org.Hs.eg.db)

# Make every conflict trigger an error
library("conflicted")

# Import custom written functions
source_files_dir <- ("Analysis")
source(here(source_files_dir, "Utils.R"))
source(here(source_files_dir, "Plotting.R"))
source(here(source_files_dir, "Color_palettes.R"))
source(here(source_files_dir, "Reference_profiles.R"))

## DECLARE GLOBAL VARIABLES
# Import environment variables as global variables
# Do not rename these variables as they are declared in Utils.R as well
objects_dir <- Sys.getenv("OBJECTS_DIR")
images_dir <- Sys.getenv("IMAGES_DIR")
images_ext <- Sys.getenv("IMAGES_EXT")
```

## Tidy Seurat object

### Separate assays

The NanoString data is stored in a single assay. The data is divided into three groups: gene expression, negative probes, and system control. The system control and negative probes are not used in the downstream analysis. The gene expression data is moved to a new assay called "RNA". The system control and negative probes are moved to new assays called "SystemControl" and "NegativeProbes", respectively. The metadata is cleaned by removing unnecessary columns and renaming others. The images are copied from the original Seurat object to a new one. The assay name in the images is updated to match the new assay name.

```{r}
#| label: load-cleaned-object

# Load cleaned object from memory
breast_cancer_patients <- readRDS(here(objects_dir, "breast_cancer_patients.rds"))
```

```{r}
#| label: create-clenaed-object
#| eval: false

# Load the original Seurat object
breast_cancer_patients_mixed_features <- readRDS(here(objects_dir, "breast.cancer.patients.original.rds"))

tidy_seurat_object_assay <- function(seurat_object_mixed_features, assay_name) {

  assay <- seurat_object_mixed_features[[assay_name]]
  
  # Extract features for the "Gene", "Negative Probes" and "System Control" assays
  system_control_features <- grep("^SystemControl", rownames(assay), value = TRUE)
  negative_probes_features <- grep("^Negative", rownames(assay), value = TRUE)
  gene_features <- dplyr::setdiff(rownames(assay), c(system_control_features, negative_probes_features))
  
  # Subset the count data for the various groups of features
  system_control_counts <- assay$counts[system_control_features, ]
  negative_probes_counts <- assay$counts[negative_probes_features, ]
  gene_counts <- assay$counts[gene_features, ]
  
  # Create new Assay objects with the respective features
  system_control_assay <- CreateAssay5Object(counts = system_control_counts)
  negative_probes_assay <- CreateAssay5Object(counts = negative_probes_counts)
  gene_assay <- CreateAssay5Object(counts = gene_counts)
  
  # Assay names
  sytem_control_assay_name <- "SystemControl"
  negative_probes_assay_name <- "NegativeProbes"
  gene_assay_name <- "RNA"
  
  # Set appropriate keys for the new assays
  system_control_assay@key <- paste0(sytem_control_assay_name, "_")
  negative_probes_assay@key <- paste0(negative_probes_assay_name, "_")
  gene_assay@key <- paste0(gene_assay_name, "_")
  
  # Create a new Seurat object
  seurat_object_cleaned_features <- CreateSeuratObject(counts = gene_assay)
  seurat_object_cleaned_features[["SystemControl"]] <- system_control_assay
  seurat_object_cleaned_features[["NegativeProbes"]] <- negative_probes_assay
  
  original_metadata <- seurat_object_mixed_features@meta.data
  
  # Specify the metadata columns to exclude
  exclude_cols <- c(
    "orig.ident",
    "nCount_Nanostring",
    "nFeature_Nanostring",
    "nn_b326beb0.2706.4f9e.a165.44afc025b72e_1_cluster_cluster_7a2d0841.7221.45b3.be66.f38ce260c6aa_1",
    "RNA_nbclust_419c19f2.965d.4b31.822e.6eba63b75b54_1_clusters",
    "RNA_nbclust_419c19f2.965d.4b31.822e.6eba63b75b54_1_posterior_probability",
    "cell",
    "nCount_RNA",
    "nFeature_RNA",
    "nCount_negprobes",
    "nFeature_negprobes",
    "Panel",
    "cellSegmentationSetId",
    "cellSegmentationSetName")

  # Remove the specified columns
  filtered_metadata <- original_metadata[, !(colnames(original_metadata) %in% exclude_cols)]
  
  # Rename one metadata column
  colnames(filtered_metadata)[which(colnames(filtered_metadata) == "cell_id")] <- "full_cell_ID"

  # Copy the metadata from the original Seurat object
  seurat_object_cleaned_features <- AddMetaData(object = seurat_object_cleaned_features, metadata = filtered_metadata)
  
  # Copy the images from the original Seurat object
  seurat_object_cleaned_features@images <- seurat_object_mixed_features@images
  # Replace the assay name with the new one
  for (image_key in names(seurat_object_cleaned_features@images)) {
    seurat_object_cleaned_features@images[[image_key]]@assay <- gene_assay_name
  }

  return(seurat_object_cleaned_features)
}

# Separate the assays in the Seurat object
breast_cancer_patients <- tidy_seurat_object_assay(breast_cancer_patients_mixed_features, "Nanostring")

# Save the cleaned object
saveRDS(breast_cancer_patients, here(objects_dir, "breast_cancer_patients.rds"))
```

### Filter out anomalous cells

```{r}
#| label: load-filtered-cells-object

# Load filtered cells object from memory
breast_cancer_patients_filt_cells <- readRDS(here(objects_dir, "breast_cancer_patients_filt_cells.rds"))
```

```{r}
#| label: create-filtered-cells-object
#| eval: false

# Read csv file with cells to remove from Seurat object
cells_to_remove <- read_csv(
  here("Analysis", "metadata", "rbc_filtered_out.csv"),
  col_types = cols("Cell.ID" = "c"))

# Remove the cells from the Seurat object
breast_cancer_patients_filt_cells <- subset(breast_cancer_patients, cells = cells_to_remove$Cell.ID)

# Find cells with extremely low or high number of Features and Counts
cells_to_remove <- WhichCells(breast_cancer_patients_filt_cells, expression = nFeature_RNA < 10 | nCount_RNA > 2500)
# Remove the cells from the Seurat object
breast_cancer_patients_filt_cells <- subset(breast_cancer_patients_filt_cells, cells = cells_to_remove, invert = TRUE)
```

```{r}
#| label: patients-groups-metadata-columns

# Name of the cell type metadata column
col_patient_group <- "patient_group"
```

```{r}
#| label: patients-groups
#| eval: false

# Define the groups
patient_groups <- list(
  "ER+" = c(
    "2",
    "4",
    "6"
  ),
  "ER-" = c(
    "1",
    "3",
    "5",
    "7"
  )
)

# Transform the list into a vector
patient_groups_vector <- setNames(rep(names(patient_groups), sapply(patient_groups, length)), unlist(patient_groups))
# Create the cell type group metadata column
# If a cell type does not belong to any cell group, copy over the cell type
breast_cancer_patients_filt_cells@meta.data %<>%
  mutate(
    "{col_patient_group}" := patient_groups_vector[as.character(.data$Patient.ID)]
  )
```

```{r}
#| label: save-filtered-cells-object
#| eval: false

# Save the filtered cells object
saveRDS(breast_cancer_patients_filt_cells, here(objects_dir, "breast_cancer_patients_filt_cells.rds"))
```

## Data overview

### Cores table

Create a table with an entry for every FOV in the Seurat object analyzed in this study. The table will contain the patient ID, the serial core, the stamp, and the FOV.

```{r}
#| label: data-overview
#| echo: false

# List of the gene data (1000-plex RNA)
print("List of the genes in the data:")
rownames(breast_cancer_patients)

# Create a data frame to store the table
patient_table <- tibble(
  Patient_ID = character(),
  Serial_Cores = character(),
  Stamps = character(),
  FOVs = character()
)
# Iterate over each patient
for (patient_id in sort(unique(unlist(breast_cancer_patients$Patient.ID)))) {
  # Subset the data for the current patient
  patient_data <- subset(x = breast_cancer_patients@meta.data, subset = Patient.ID == patient_id)

  # Get the unique serial cores for the current patient
  serial_cores <- unique(patient_data$core_serial)

  # Iterate over each serial core
  for (serial_core_id in serial_cores) {
    # Subset the data for the current serial core
    serial_core_data <- subset(x = patient_data, subset = core_serial == serial_core_id)

    # Get the unique stamps for the current serial core
    stamps <- unique(serial_core_data$stamp)
    
    # Iterate over each stamp
    for (stamp_id in stamps) {
      # Subset the data for the current stamp
      stamp_data <- subset(x = serial_core_data, subset = stamp == stamp_id)

      # Get the unique FOVs for the current stamp
      fovs <- unique(stamp_data$fov)

      # Add a row to the patient table for each FOV
      for (fov_id in fovs) {
        patient_table <- patient_table %>% add_row(
          Patient_ID = as.character(patient_id),
          Serial_Cores = as.character(serial_core_id),
          Stamps = as.character(stamp_id),
          FOVs = as.character(fov_id)
        )
      }
    }
  }
}
# Sort the patient_table by Patient_ID, Serial_Cores, and Stamps
patient_table <- patient_table %>%
  arrange(Patient_ID, Serial_Cores, Stamps, desc(FOVs))
# Print the patient table
print(patient_table)

# Print patients info
print("Patients")
patients_ids <- sort(unique(unlist(breast_cancer_patients$Patient.ID)))
print(glue("IDs: {glue_collapse(patients_ids, sep = ', ')}"))
patients_total <- length(patients_ids)
print(glue("Total: {patients_total}"))

# Print cores info
print("Cores")
breast_cancer_cores_names <- sort(unique(breast_cancer_patients@meta.data$core_serial))
print(glue("Names: {glue_collapse(breast_cancer_cores_names, sep = ', ')}"))
breast_cancer_cores_total <- length(breast_cancer_cores_names)
print(glue("Total: {breast_cancer_cores_total}"))

# Print stamps info
print("Stamps")
breast_cancer_stamps_total <- length(unique(paste(
  breast_cancer_patients@meta.data$core_serial,
  breast_cancer_patients@meta.data$stamp)))
print(glue("Total: {breast_cancer_stamps_total}"))

# Print FOVs info
print("FOVs")
breast_cancer_fovs_nums <- sort(unique(unlist(breast_cancer_patients$fov)))
print(glue("Numbers: {glue_collapse(breast_cancer_fovs_nums, sep = ', ')}"))
breast_cancer_fovs_total <- length(breast_cancer_fovs_nums)
print(glue("Total: {breast_cancer_fovs_total}"))
```

### Tissue micro array

Print the patients' information and create two representation of the TMA: one with the primary diagnosis highlighted and one with the quality of the FOVs with a primary diagnosis of breast cancer highlighted.

```{r}
#| label: TMA-info

# List with plots & dataframe to be saved
TMA_info_to_save <- list()
# List with plots & dataframe to be displayed
TMA_info_to_display <- list()

# Information about the patients involved in the study
patient_info <- read_excel(here("Analysis", "metadata", "updatedPACC_Copy of METBRA_patient_v1_now_updated_dec_2022_GOOD_mar_2024_Lanzing.xlsx"))
TMA_info_to_display[["Patient_info"]] <- patient_info

# FOVs & Core serials
LU001FFP03_FOV <- read_excel(here("Analysis", "metadata", "LU001FFP03_FOV.xlsx"))
# Core serials, Patients' ID & Primary Diagnosis
TMA_METBRA_COSMX <- read_excel(
  path = here("Analysis", "metadata", "TMA_METBRA_COSMX Analysis.xlsx"),
  sheet = "TMA_list")
# FOVs & associated primary diagnosis
FOVs_primary_diagnosis <- left_join(
  x = LU001FFP03_FOV,
  y = TMA_METBRA_COSMX,
  by = c("core_serial" = "Full Serial Number"))
# X, Y & Z FOVs positions
tissue_micro_array <- read_csv(gzfile(
  here("Analysis", "flat_files", "LU001FFP03", "LU001FFP03_fov_positions_file.csv.gz")),
  col_types = cols(
  Slide = col_integer(),
  X_mm = col_double(),
  Y_mm = col_double(),
  Z_mm = col_double(),
  ZOffset_mm = col_double(),
  ROI = col_integer(),
  FOV = col_integer(),
  Order = col_integer(),
  Run_Tissue_name = col_character()))
# FOVs, associated primary diagnosis & X, Y, Z positions
FOVs_prim_diag_pos <- left_join(
  x = tissue_micro_array,
  y = FOVs_primary_diagnosis,
  by = c("FOV" = "fov"))
# FOVs, associated primary diagnosis, X, Y positions & quality
FOVs_prim_diag_pos_qual <- FOVs_prim_diag_pos %>%
  dplyr::mutate(Quality = case_when(
    is.na(`Primary Diagnosis`) ~ NA_character_,
    `Primary Diagnosis` != "breast cancer" ~ NA_character_,
    FOV %in% breast_cancer_fovs_nums ~ "good",
    TRUE ~ "bad"
  ))

# Plots shared parameters
square_size <- 5
square_text_size <- 1.6
title <- "TMA LU001FFP03"

# TMA plot with FOVs positions and associated primary diagnosis
LU001FFP03_TMA_primary_diag <- ggplot(FOVs_prim_diag_pos_qual, aes(x = X_mm, y = Y_mm)) +
  geom_point(aes(color = `Primary Diagnosis`), shape = 15, size = square_size) +
  geom_text(aes(label = FOV), size = square_text_size) +
  coord_equal() +
  labs(title = title,
       color = "Primary diagnosis") +
  scale_color_manual(values = c("breast cancer" = "#00B5EE", "lung cancer" = "#E26EF7"),
                     na.translate = TRUE, 
                     na.value = "grey50",
                     breaks = c("breast cancer", "lung cancer"))
LU001FFP03_TMA_primary_diag_name <- paste0("TMA_LU001FFP03_primary_diagnosis_highlighted")
TMA_info_to_save[[LU001FFP03_TMA_primary_diag_name]] <- LU001FFP03_TMA_primary_diag

# TMA plot with FOVs positions and quality of those with primary diagnosis of breast cancer
LU001FFP03_TMA_breast_cancers_stamps_quality <- ggplot(
  FOVs_prim_diag_pos_qual, aes(x = X_mm, y = Y_mm)) +
  geom_point(aes(color = `Quality`), shape = 15, size = square_size) +
  geom_text(aes(label = FOV), size = square_text_size) +
  coord_equal() +
  labs(title = title,
       color = "Breast cancer\nstamps quality") +
  scale_color_manual(values = c("good" = "#00BB44", "bad" = "#F8766D"),
                     na.translate = TRUE, 
                     na.value = "grey50",
                     breaks = c("good", "bad"))
LU001FFP03_TMA_breast_cancer_stamps_highlighted_name <- 
  paste0("TMA_LU001FFP03_breast_cancer_stamps_quality")
TMA_info_to_save[[LU001FFP03_TMA_breast_cancer_stamps_highlighted_name]] <- 
  LU001FFP03_TMA_breast_cancers_stamps_quality

print(c(TMA_info_to_display, TMA_info_to_save))
```

```{r}
#| label: save-plots-TMA-info
#| include: false
#| echo: false
#| eval: false

save_data(TMA_info_to_save, here(images_dir, "TMA"), images_ext)
```

## Quality assurance

```{r}
#| label: qa

# Check if there are mitochondrial genes
mt_gene_count <- sum(grepl("^MT-", rownames(breast_cancer_patients_filt_cells[["RNA"]])))
if (mt_gene_count > 0) {
  cat("TRUE. Number of mitochondrial genes:", mt_gene_count)
} else {
  cat("FALSE. No mitochondrial genes found.")
}
```

## Insitutype Clustering

The clustering performed by Insitutype  uses the raw counts, therefore it is useless to use the integrated data because Seurat does not provide an adjusted count matrix.

```{r}
#| label: ins-metadata-columns

# Name of the column with the raw insitutype clusters
col_ist_raw <- "patients_ist_semisup_clusters"
# Name of the metadata column with the annotated insitutype clusters
col_ist_ann <- "patients_ist_semisup_clusters_ann"
```

### Compute

```{r}
#| label: insitutype-read-from-drive

# Read the Insitutype data from the drive
breast_cancer_patients_analyze <- readRDS(here(objects_dir, "breast_cancer_patients_analyze.rds"))
patients_ist_semisup <- readRDS(here(objects_dir, "patients_ist_semisup.rds"))
```

```{r}
#| label: insitutype-per-patient
#| eval: false

# Create a new Seurat object identical to filt cells
breast_cancer_patients_analyze <- breast_cancer_patients_filt_cells
# Arrays to split
assays_to_split <- c("RNA", "NegativeProbes", "SystemControl")
# Split the arrays
for (assay in assays_to_split) {
  breast_cancer_patients_analyze[[assay]] <- split(
    breast_cancer_patients_analyze[[assay]],
    f = breast_cancer_patients_analyze$Patient.ID)
}
# Set Patient.ID as the identity
Idents(breast_cancer_patients_analyze) <- "Patient.ID"

# Create a list to store the results of the insitutype clustering per patient
patients_ist_semisup <- list()
# Create a list to store the results of the cluster num search function
patients_clusters_num_search_info <- list()
# Set the reference profile
reference_profile <- io_brain_profiles_matrix
# Insitutype clustering - Loop over every patient
for (patient_id in unique(breast_cancer_patients_analyze$Patient.ID)) {

  # Print the patient ID
  print(glue("Analysis of patient {patient_id}"))
  # Compose string of count layer patient
  count_layer_patient <- paste0("counts.", patient_id)
  # Extract the count data for the selected patient
  patient_rna_counts <- LayerData(
    breast_cancer_patients_analyze,
    assay = "RNA",
    layer = count_layer_patient) %>%
  as.matrix() %>%
  t()
  
  # Extract the negative probes for the selected patient
  patient_avg_neg_probes <- LayerData(
    breast_cancer_patients_analyze,
    assay = "NegativeProbes",
    layer = count_layer_patient) %>%
  as.matrix() %>%
  t() %>%
  Matrix::rowMeans()
  
  # Features to be used for the cohorting
  features <- c("Mean.PanCK", "Mean.CD45", "Mean.CD68")
  patient_immunofluorescence <- FetchData(
  object = breast_cancer_patients_analyze, 
  vars = features, # Specify which metadata columns to extract
  cells = WhichCells(breast_cancer_patients_analyze, idents = patient_id)
  )
  
  # Cohort of the patient
  # fastCohorting is stochastic, so set the seed for reproducibility
  set.seed(42);
  # "Gaussian_transform = TRUE" maps variables to gaussians in order to place dramatically different variables on the same scale
  patient_cohort <- fastCohorting(
    patient_immunofluorescence,
    gaussian_transform = TRUE)
  # check clusters and cohort numbers
  table(patient_cohort)
  
  # Set the range to search for the optimal number of extra clusters
  clusts_search_space = 1:8
  set.seed(6)
  # Search the optimal numer of extra clusters
  clusters_num_search_info <- chooseClusterNumber(
    counts = patient_rna_counts,
    neg = patient_avg_neg_probes,
    fixed_profiles = reference_profile,
    n_clusts = clusts_search_space)
  # Save the result to a list
  patients_clusters_num_search_info[[patient_id]] <- clusters_num_search_info
  
  # Get the best number of clusters
  clusts_num <- clusters_num_search_info$best_clust_number
  # Print the best number of clusters
  print(glue("Best number of clusters: {clusts_num}"))
  
  # Semi-supervised learning with insitutype and reference profiles
  # Insitutype needs integers, if given floating point numbers it fails with misleading errors
  patients_ist_semisup[[patient_id]] <- insitutype(
    x = patient_rna_counts,
    neg = patient_avg_neg_probes,
    cohort = patient_cohort,
    
    # Enter your own per-cell background estimates here if you
    # have them; otherwise insitutype will use the negprobes to
    # estimate background for you.
    bg = NULL,
    # Group the cells the do not correspond to any type in the reference matrix
    n_clusts = 1,
    reference_profiles = reference_profile,
    # Update the reference profile based on the current data
    update_reference_profiles = FALSE,
    # choosing inadvisably low numbers to speed the vignette; using the defaults
    # in recommended.
    # This is the number of cells used in each phase, because of random sampling
    n_phase1 = 200,
    n_phase2 = 500,
    n_phase3 = 1000,
    n_starts = 6,
    max_iters = 12
  )
}

# Join Layers
for (assay in assays_to_split) {
  breast_cancer_patients_analyze <- JoinLayers(breast_cancer_patients_analyze, assay = assay, layers = "counts")
}

# Merge patient insitutype clusters
merged_ist_results <- c()
for (i in 1:length(patients_ist_semisup)) {
  merged_ist_results <- c(merged_ist_results, patients_ist_semisup[[i]]$clust)
}
# Add the raw insitutype clusters to the Seurat object
breast_cancer_patients_analyze <- AddMetaData(
  object = breast_cancer_patients_analyze,
  metadata = merged_ist_results,
  col.name = col_ist_raw)

# Rename unknown clusters to tumor
breast_cancer_patients_analyze@meta.data %<>%
  mutate(
    "{col_ist_ann}" := case_match(
      .data[[col_ist_raw]],
      c("a") ~ "Other",
      .default = .data[[col_ist_raw]]
    )
  )
```

```{r}
#| label: insitutype-info

ist_info <- list()

ist_summary_table <- breast_cancer_patients_analyze@meta.data %>%
  count(!!sym(col_ist_ann), Patient.ID) %>%
  group_by(Patient.ID) %>%
  mutate(percentage = n / sum(n) * 100) %>%
  arrange(Patient.ID, !!sym(col_ist_ann)) %>%
  dplyr::rename(cell_type = !!sym(col_ist_ann)) %>%
  as_tibble()
ist_info[["ist_summary_table"]] <- ist_summary_table

print(ist_info)
```

```{r}
#| echo: false

# Save the Insitutype plots
save_data(ist_info, here(images_dir, "Insitutype"))
```

### Cell groups

```{r}
#| label: cell-groups-metadata-columns

# Name of the cell type metadata column
col_cell_group <- "cell_group"
```

```{r}
#| label: cells-groups
#| eval: false

# Define the groups
cell_groups <- list(
  "Myeloids" = c(
    "Macrophage",
    "Mast cell",
    "Monocyte",
    "Neutrophil",
    "Dendritic cell",
    "Plasmacytoid dendritic cell"
  ),
  "Stromal cells" = c(
    "Endothelial",
    "Fibroblast"
  ),
  "Lymphocytes" = c(
    "B cell",
    "T cell CD4",
    "T cell CD8",
    "T cell regulatory",
    "NK cell",
    "Plasma",
    "Plasmablast"
  ),
  "Brain cells" = c(
    "Inhibitory neuron A",
    "Inhibitory neuron B",
    "Inhibitory neuron C",
    # Excitatory neurons
    "L2/3 neuron",
    "L4 neuron",
    "L6 neuron",
    # Glial cells
    "Oligodendrocyte-like",
    "Oligodendrocyte precursor cell",
    "Oligodendrocyte",
    # Microglia cells
    "Microglia A",
    "Microglia B",
    # Astrocyte cells
    "Astrocyte A",
    "Astrocyte B"
  )
)

# Transform the list into a vector
cell_groups_vector <- setNames(rep(names(cell_groups), sapply(cell_groups, length)), unlist(cell_groups))
# Create the cell type group metadata column
# If a cell type does not belong to any cell group, copy over the cell type
breast_cancer_patients_analyze@meta.data %<>%
  mutate(
    "{col_cell_group}" := ifelse(
      is.na(cell_groups_vector[.data[[col_ist_ann]]]),
      .data[[col_ist_ann]],
      cell_groups_vector[.data[[col_ist_ann]]]
    )
  )
```

### SCTransform

```{r}
#| label: rna-sctransform-calculate
#| eval: false

## SCTransform
# Normalize and scale
breast_cancer_patients_analyze <- SCTransform(
  breast_cancer_patients_analyze,
  do.correct.umi = TRUE,
  return.only.var.genes = FALSE,
  ncells = 6000,
  assay = "RNA",
  new.assay.name = "SCT",
  seed.use = 13,
  verbose = TRUE)
# Run PCA
breast_cancer_patients_analyze <- RunPCA(
  breast_cancer_patients_analyze,
  assay = "SCT",
  reduction.key = "SCTPC_",
  reduction.name = "sct_pca_patients",
  seed.use = 42,
  verbose = TRUE)
# Elbow plot
patients_sct_elbow_plot <- generate_variance_elbow_plots(breast_cancer_patients_analyze, "sct_pca_patients", 50)
print(patients_sct_elbow_plot)
# Run UMAP
breast_cancer_patients_analyze <- RunUMAP(
  breast_cancer_patients_analyze,
  reduction = "sct_pca_patients",
  dims = 1:22,
  reduction.key = "SCTUMAP_",
  reduction.name = "sct_umap_patients",
  seed.use = 42)
```

```{r}
#| label: rna-sctransform-plot

# List to print and save
patients_ist_sct <- list()

# Plot cells by type
patients_ist_type_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_ist_ann,
  reduction = "sct_umap_patients",
  cols = palette_cell_types) +
  labs(title = "Insitutype clusters") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      ncol=1,
      keywidth = unit(0.5, "lines"),
      keyheight = unit(0.8, "lines"),
      spacing = unit(0.2, "lines"))
  ) +
  theme_classic(base_size = 9) &
  NoAxes()
patients_ist_sct[["patients_ist_type_sct_plot"]] <- patients_ist_type_sct_plot

# Plot cells by group
patients_ist_group_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_cell_group,
  reduction = "sct_umap_patients",
  cols = palette_cell_types) +
  labs(title = "Insitutype cell groups") &
  NoAxes()
patients_ist_sct[["patients_ist_group_sct_plot"]] <- patients_ist_group_sct_plot

# Plot patients
patients_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = "Patient.ID",
  reduction = "sct_umap_patients",
  cols = palette_patients) +
  labs(title = "All cells") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      title = "Patient"
    )
  ) &
  NoAxes()
patients_ist_sct[["patients_sct_plot"]] <- patients_sct_plot

# Plot estrogen receptors
estrogen_receptor_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_patient_group,
  reduction = "sct_umap_patients",
  cols = palette_tumor_types) +
  labs(title = "All cells") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      title = "Patient"
    )
  ) &
  NoAxes()
patients_ist_sct[["estrogen_receptor_sct_plot"]] <- estrogen_receptor_sct_plot

Idents(breast_cancer_patients_analyze) <- "neutral"
# Check the quantity and the expression level of genes after normalization
vln_plot_feat_count_sct <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "SCT",
  layer = "data",
  features = c("nFeature_SCT", "nCount_SCT"),
  ncol = 2,
  pt.size = 0
)
# Customize the titles for each plot
vln_plot_feat_count_sct[[1]] <- vln_plot_feat_count_sct[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_sct[[2]] <- vln_plot_feat_count_sct[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_sct <- vln_plot_feat_count_sct + plot_annotation(title = "After SCT normalization")
# Save the plot
patients_ist_sct[["Violin_plot_features_count_sct"]] <- vln_plot_feat_count_sct

# Check the quantity and the expression level of genes per patient after normalization
vln_plot_feat_count_patients_sct <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "SCT",
  layer = "data",
  features = c("nFeature_SCT","nCount_SCT"),
  ncol = 2,
  pt.size = 0,
  group.by = "Patient.ID",
  cols = palette_patients
)
# Customize the titles for each plot
vln_plot_feat_count_patients_sct[[1]] <- vln_plot_feat_count_patients_sct[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_patients_sct[[2]] <- vln_plot_feat_count_patients_sct[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_patients_sct <- vln_plot_feat_count_patients_sct + plot_annotation(title = "After SCT normalization")
# Save the plot
patients_ist_sct[["Violin_plot_patients_features_count_sct"]] <- vln_plot_feat_count_patients_sct

# QC the normalization
feature_plot_feat_count_sct <- FeaturePlot(
  breast_cancer_patients_analyze,
  features = c("nFeature_RNA", "nCount_RNA"),
  reduction = "sct_umap_patients",
  combine = TRUE) + 
  plot_annotation(title = "After SCT normalization")
# Save the plot
patients_ist_sct[["Feature_plot_features_count_sct"]] <- feature_plot_feat_count_sct

# Print
print(patients_ist_sct)
```

### Standard normalization

```{r}
#| label: rna-standard-normalization-calculate
#| eval: false

# Default assay & layer
DefaultAssay(breast_cancer_patients_analyze) <- "RNA"
DefaultLayer(breast_cancer_patients_analyze[["RNA"]]) <- "counts"

# Normalize
breast_cancer_patients_analyze <- NormalizeData(
  breast_cancer_patients_analyze,
  assay = "RNA")
# Scale
breast_cancer_patients_analyze <- ScaleData(
  breast_cancer_patients_analyze,
  assay = "RNA")
# Find variable features
breast_cancer_patients_analyze <- FindVariableFeatures(
  breast_cancer_patients_analyze,
  selection.method = "vst",
  nfeatures = 1000,
  assay = "RNA")
# RunPCA
breast_cancer_patients_analyze <- RunPCA(
  breast_cancer_patients_analyze,
  assay = "RNA",
  reduction.key = "RNAPC_",
  reduction.name = "rna_pca_patients",
  seed.use = 42,
  verbose = TRUE)
# Elbow plot
patients_rna_elbow_plot <- generate_variance_elbow_plots(breast_cancer_patients_analyze, "rna_pca_patients", 50)
print(patients_rna_elbow_plot)
# Run UMAP
breast_cancer_patients_analyze <- RunUMAP(
  breast_cancer_patients_analyze,
  reduction = "rna_pca_patients",
  dims = 1:22,
  reduction.key = "RNAUMAP_",
  reduction.name = "rna_umap_patients",
  seed.use = 42)
```

```{r}
#| label: rna-standard-normalization-plot

# List to print and save
patients_ist_rna <- list()

# Plot cells
patients_ist_type_rna_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = "patients_ist_semisup_clusters_ann",
  reduction = "rna_umap_patients",
  cols = palette_cell_types)
patients_ist_rna[["patients_ist_type_rna_plot"]] <- patients_ist_type_rna_plot
# Plot patients
patients_rna_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = "Patient.ID",
  reduction = "rna_umap_patients",
  cols = palette_patients)
patients_ist_rna[["patients_rna_plot"]] <- patients_rna_plot

Idents(breast_cancer_patients_analyze) <- "neutral"
# Check the quantity and the expression level of genes after normalization
vln_plot_feat_count_rna <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "RNA",
  layer = "data",
  features = c("nFeature_RNA", "nCount_RNA"),
  ncol = 2,
  pt.size = 0
)
# Customize the titles for each plot
vln_plot_feat_count_rna[[1]] <- vln_plot_feat_count_rna[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_rna[[2]] <- vln_plot_feat_count_rna[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_rna <- vln_plot_feat_count_rna + plot_annotation(title = "After RNA normalization")
# Save the plot
patients_ist_rna[["Violin_plot_features_count_rna"]] <- vln_plot_feat_count_rna

# Check the quantity and the expression level of genes per patient after normalization
vln_plot_feat_count_patients_rna <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "RNA",
  layer = "data",
  features = c("nFeature_RNA","nCount_RNA"),
  ncol = 2,
  pt.size = 0,
  group.by = "Patient.ID",
  cols = palette_patients
)
# Customize the titles for each plot
vln_plot_feat_count_patients_rna[[1]] <- vln_plot_feat_count_patients_rna[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_patients_rna[[2]] <- vln_plot_feat_count_patients_rna[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_patients_rna <- vln_plot_feat_count_patients_rna + plot_annotation(title = "After RNA normalization")
# Save the plot
patients_ist_rna[["Violin_plot_patients_features_count_rna"]] <- vln_plot_feat_count_patients_rna

# QC the normalization
feature_plot_feat_count_rna <- FeaturePlot(
  breast_cancer_patients_analyze,
  features = c("nFeature_RNA", "nCount_RNA"),
  reduction = "rna_umap_patients",
  combine = TRUE) + 
  plot_annotation(title = "After RNA normalization")
# Save the plot
patients_ist_rna[["Feature_plot_features_count_rna"]] <- feature_plot_feat_count_rna

# Print
print(patients_ist_rna)
```

### Plot

```{r}
#| label: insitutype-plot

# Save insitutype data
insitutype_data <- list()

# Generate summary statistics for the Insitutype clusters
insitutype_data[["insitutype_clust_summary_patients"]] <- create_cluster_summary_per_patient(breast_cancer_patients_analyze, col_ist_ann)

# Violin plot with the expression of panCK, CD45 and CD68 for each Insitutype clusters
ist_clust_expr <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "RNA",
  layer = "data",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  pt.size = 0,
  group.by = col_ist_ann,
  combine = FALSE,
  cols = palette_cell_types
)
ist_clust_expr <- lapply(ist_clust_expr, function(x) x &NoLegend())
insitutype_data <- c(insitutype_data, ist_clust_expr)

# Calculate the mean of CD45, CD68 and PanCK for each Insitutype cluster
ist_ann_cluster_statistics <- breast_cancer_patients_analyze@meta.data %>%
  group_by(!!sym(col_ist_ann)) %>%
  summarise(
    `Mean PanCK` = mean(Mean.PanCK),
    `Mean CD45` = mean(Mean.CD45),
    `Mean CD68` = mean(Mean.CD68),
    .groups = "drop"
  )
insitutype_data[["ist_ann_cluster_statistics"]] <- ist_ann_cluster_statistics

print(insitutype_data)
```

```{r}
#| label: insitutype-save-data
#| eval: false

# Save the Insitutype plots
save_data(patients_ist_sct, here(images_dir, "Insitutype"))
save_data(patients_ist_rna, here(images_dir, "Insitutype"))
save_data(insitutype_data, here(images_dir, "Insitutype"))
```

```{r}
#| label: insitutype-save-rds
#| eval: false

# Save insitutype list
saveRDS(patients_ist_semisup, here(objects_dir, "patients_ist_semisup.rds"))
# Save Seurat object
saveRDS(breast_cancer_patients_analyze, here(objects_dir, "breast_cancer_patients_analyze.rds"))
```

## Split

Create two separate Seurat objects for tumor and normal cells using the Insitutype clusters

```{r}
#| label: insitutype-add-metadata
#| eval: false

# Add insitutype annotated clusters to filt cells object
breast_cancer_patients_filt_cells <- AddMetaData(
  object = breast_cancer_patients_filt_cells,
  metadata = FetchData(
    object = breast_cancer_patients_analyze,
    vars = col_ist_ann),
  col.name = col_ist_ann
)
# Add insitutype group clusters to filt cells object
breast_cancer_patients_filt_cells <- AddMetaData(
  object = breast_cancer_patients_filt_cells,
  metadata = FetchData(
    object = breast_cancer_patients_analyze,
    vars = col_cell_group),
  col.name = col_cell_group
)
```

```{r}
#| label: insitutype-split
#| eval: false

# Extract the Insitutype clusters metadata column
ist_ann_column <- FetchData(
  object = breast_cancer_patients_filt_cells,
  vars = col_ist_ann)
# Create Seurat objects with the non-cancerous cells
breast_cancer_patients_normal_cells <- 
  breast_cancer_patients_filt_cells[, which(x = ist_ann_column != "Other")]
# Create Seurat objects with the cancerous cells
breast_cancer_patients_other_cells <-
  breast_cancer_patients_filt_cells[, which(x = ist_ann_column == "Other")]
```

## Normal cells

### Compute

```{r}
#| label: normal-cells-read-from-drive

# Load normal cells object from memory
breast_cancer_patients_normal_cells <- readRDS(here(objects_dir, "breast_cancer_patients_normal_cells.rds"))
```

```{r}
#| label: normal-cells-computation
#| eval: false

# Run SCTransform
breast_cancer_patients_normal_cells <- SCTransform(
  breast_cancer_patients_normal_cells,
  do.correct.umi = TRUE,
  return.only.var.genes = FALSE,
  assay = "RNA",
  new.assay.name = "SCT",
  seed.use = 13,
  verbose = TRUE)
# Run PCA
breast_cancer_patients_normal_cells <- RunPCA(
  breast_cancer_patients_normal_cells,
  assay = "SCT",
  reduction.key = "SCTPC_",
  reduction.name = "sct_pca_normal_cells",
  seed.use = 42,
  verbose = TRUE)
# Generate variance elbow plots
generate_variance_elbow_plots(breast_cancer_patients_normal_cells, "sct_pca_normal_cells", 50)
# Run UMAP
breast_cancer_patients_normal_cells <- RunUMAP(
  breast_cancer_patients_normal_cells,
  reduction = "sct_pca_normal_cells",
  dims = 1:30,
  reduction.key = "SCTUMAP_",
  reduction.name = "sct_umap_normal_cells",
  seed.use = 42)
```

### Plot

```{r}
#| label: normal-cells-plot

# Create empty list to store normal cells images
normal_cells_images <- list()

# Calculate the statistics for the normal cells
normal_cells_cluster_statistics <- breast_cancer_patients_normal_cells@meta.data %>%
  # Group by patient and cluster, then calculate percentage
  group_by(Patient.ID, !!sym(col_ist_ann), !!sym(col_cell_group)) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Patient.ID) %>%
  mutate(Percentage = count / sum(count) * 100) %>%
  ungroup() %>%
  # Ensure Patient.ID is a factor
  mutate(Patient.ID = as.factor(Patient.ID)) %>%
  # Calculate mean and sd for each cluster
  group_by(!!sym(col_ist_ann)) %>%
  mutate(
    MeanPercentage = mean(Percentage),
    SDPercentage = sd(Percentage)
  ) %>%
  ungroup()
normal_cells_images[["normal_cells_cluster_statistics"]] <- normal_cells_cluster_statistics

# Plot the percentages of the various types of cells (except cancer cells)
normal_cells_cluster_distribution_barplot <- normal_cells_cluster_statistics %>%
  # Plot the data in a grouped barplot
  ggplot(aes(x = !!sym(col_ist_ann), y = Percentage, fill = Patient.ID)) +
  geom_bar(stat = "identity", position = position_dodge2(preserve = "single", padding = 0), width = .8) +
  facet_grid(cols = ggplot2::vars(!!sym(col_cell_group)), scales = "free_x", space = "free") +
  theme_minimal() +
  labs(x = NULL, 
       y = "Percentage of Cells", 
       title = "Normal Cells Types Distribution by Patient",
       fill = "Patient") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.spacing = unit(0.8, "lines")) +
  scale_fill_manual(values = palette_patients)
normal_cells_images[["normal_cells_cluster_distribution_barplot"]] <- normal_cells_cluster_distribution_barplot

# Plot the distribution of normal cell clusters by patient
normal_cells_cluster_distribution_dotplot <- normal_cells_cluster_statistics %>%
  # Plot the data
  ggplot(aes(x = Percentage, y = !!sym(col_ist_ann))) +
  # Add dots for each patient
  geom_point(aes(color = Patient.ID), size = 3, alpha = 0.7) +
  # Add mean percentage point
  stat_summary(aes(shape = "Mean"), fun = mean, geom = "point", size = 5, color = "black", alpha = 0.7) +
  # Add standard deviation error bars
  geom_errorbarh(aes(xmin = MeanPercentage - SDPercentage, 
                     xmax = MeanPercentage + SDPercentage, 
                     y = !!sym(col_ist_ann),
                     linetype = "Standard Deviation"), 
                 color = "black", alpha = 0.7, height = 0.5, linewidth = 0.2) +
  theme_minimal() +
  ggforce::facet_col(
    facets = col_cell_group,
    scales = "free_y",
    space = "free",
    drop = TRUE,
    strip.position = "top"
  ) +
  labs(x = "Percentage of Cells", y = NULL,
       title = "Normal Cells Types Distribution by Patient",
       color = "Patient") +
  scale_color_manual(values = palette_patients) +
  scale_shape_manual(values = c("Mean" = 18), labels = c("Mean")) +
  scale_linetype_manual(values = c("Standard Deviation" = "solid"), labels = c("Standard Deviation")) +
  guides(
    color = guide_legend(order = 1),
    shape = guide_legend(order = 2, title = "Statistics"),
    linetype = guide_legend(order = 3, title = "Statistics")
  )
normal_cells_images[["normal_cells_cluster_distribution_dotplot"]] <- normal_cells_cluster_distribution_dotplot

# Umap normal cells patients
normal_cells_patients_umap_plot <- DimPlot(
  object = breast_cancer_patients_normal_cells,
  group.by = "Patient.ID",
  reduction = "sct_umap_normal_cells",
  cols = palette_patients
  )  +
  labs(title = "Normal cells") +
  guides(
    color = guide_legend(
      title = "Patient",
      override.aes = list(size=2)
    )
  ) &
  NoAxes()
normal_cells_images[["normal_cells_patients_umap_plot"]] <- normal_cells_patients_umap_plot

# Umap normal cells types
normal_cells_type_umap_plot <- DimPlot(
  object = breast_cancer_patients_normal_cells,
  group.by = col_ist_ann,
  reduction = "sct_umap_normal_cells",
  cols = palette_cell_types
  )  +
  labs(title = "Normal cells clusters") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      ncol=1,
      keywidth = unit(0.5, "lines"),
      keyheight = unit(0.8, "lines"),
      spacing = unit(0.2, "lines"))
  ) +
  theme_classic(base_size = 9) &
  NoAxes()
normal_cells_images[["normal_cells_type_umap_plot"]] <- normal_cells_type_umap_plot

# Umap normal cells groups
normal_cells_group_umap_plot <- DimPlot(
  object = breast_cancer_patients_normal_cells,
  group.by = col_cell_group,
  reduction = "sct_umap_normal_cells",
  cols = palette_cell_types
  )  +
  labs(title = "Normal cells groups") &
  NoAxes()
normal_cells_images[["normal_cells_group_umap_plot"]] <- normal_cells_group_umap_plot

print(normal_cells_images)
```

```{r}
#| label: normal-cells-save-plots
#| eval: false

# Save the normal cells plots
save_data(normal_cells_images, here(images_dir, "Normal cells"))
```

```{r}
#| label: normal-cells-save-rds
#| eval: false

# Save the Seurat object
saveRDS(breast_cancer_patients_normal_cells, here(objects_dir, "breast_cancer_patients_normal_cells.rds"))
```

## Other cells

### Cluster

```{r}
#| label: other-cells-read-from-drive

# Load other cells object from memory
breast_cancer_patients_other_cells <- readRDS(here(objects_dir, "breast_cancer_patients_other_cells.rds"))
```

```{r}
#| label: other-cells-metadata-columns

# Name of the metadata column with the other clusters
col_other_cells_clust_res_prefix <- "other_cells_clusters_res_"
# Find clusters of other cells
# The default resolution is 1, increase it to get more clusters or decrease it to get fewer clusters
# Try a range of resolutions
seq_res <- seq(0.1, 0.4, by = 0.1)
# Create custom cluster names based on the actual resolution values
other_cells_cluster_seq_res <- glue::glue("{col_other_cells_clust_res_prefix}{seq_res}")
```

```{r}
#| label: other-cells-compute
#| eval: false

# After subsetting a Seurat object it is good to normalize it again
breast_cancer_patients_other_cells <- SCTransform(
  breast_cancer_patients_other_cells,
  return.only.var.genes = FALSE,
  assay = "RNA",
  new.assay.name = "SCT",
  verbose = TRUE)

# Run PCA
breast_cancer_patients_other_cells <- RunPCA(
  breast_cancer_patients_other_cells,
  reduction.key = "PC_",
  reduction.name = "pca",
  seed.use = 42,
  verbose = TRUE)
# Generate variance elbow plots
generate_variance_elbow_plots(breast_cancer_patients_other_cells, "pca", 50)
# Dimension to use for subsequent analysis, decided lokking at the elbow plot
other_cells_dims <- 1:23
# Find neighbors of other cells
# Number of PCA dimensions used in Seurat's FindNeighbors function
#
# Using MORE dimensions:
# Captures more subtle biological variation
# Includes more complex relationships between genes
# May include more noise/technical artifacts
# Computationally more intensive
#
# Using FEWER dimensions:
# Focuses on major sources of variation
# More robust to technical noise
# May miss subtle biological signals
# Computationally faster
breast_cancer_patients_other_cells <- FindNeighbors(
  breast_cancer_patients_other_cells,
  reduction = "pca",
  dims = other_cells_dims,
  verbose = TRUE)

# Find clusters at different resolutions
breast_cancer_patients_other_cells <- FindClusters(
  breast_cancer_patients_other_cells,
  resolution = seq_res,
  cluster.name = other_cells_cluster_seq_res,
  random.seed = 5,
  verbose = TRUE)

# Run UMAP
breast_cancer_patients_other_cells <- RunUMAP(
  breast_cancer_patients_other_cells,
  reduction = "pca",
  reduction.key = "UMAP_",
  reduction.name = "umap",
  dims = other_cells_dims,
  verbose = TRUE,
  seed.use = 42)
```

### Plot

```{r}
#| label: other-cells-plot

other_cells_plots_to_save <- list()

# View UMAP with other cells at different clustering resolutions
other_cells_different_resolutions <- DimPlot(
  breast_cancer_patients_other_cells,
  reduction="umap",
  ncol=2,
  group.by=other_cells_cluster_seq_res,
  label=TRUE,
  ) & 
  NoLegend() & 
  NoAxes() & 
  theme(
  plot.margin = unit(c(0, 0, 0, 0), "lines"),
  plot.title = element_text(size = 12, face = "bold")
  )
other_cells_plots_to_save[["other_cells_different_resolutions"]] <- other_cells_different_resolutions

# View UMAP with other cells and patient clusters
other_cells_patient_id_plot <- DimPlot(
  breast_cancer_patients_other_cells,
  reduction = "umap",
  label = TRUE,
  label.box=TRUE,
  group.by = "Patient.ID",
  cols = palette_patients) +
  labs(title = "Patient ID clusters") &
  NoLegend() &
  NoAxes()
other_cells_plots_to_save[["other_cells_patient_id_plot"]] <- other_cells_patient_id_plot

# Chosen resolution
chosen_other_cells_cluster_resolution <- 0.2
# Chosen cluster
col_other_cells_chosen_cluster <- glue::glue("{col_other_cells_clust_res_prefix}{chosen_other_cells_cluster_resolution}")
# Set identity to other clusters
Idents(breast_cancer_patients_other_cells) <- col_other_cells_chosen_cluster

# Generate DimPlot of chosen resolution
other_cells_chosen_resolution_plot <- DimPlot(
  breast_cancer_patients_other_cells,
  reduction = "umap",
  group.by = col_other_cells_chosen_cluster,
  label = TRUE) +
  labs(title = "Other Cell Clusters") &
  NoLegend() &
  NoAxes()
# Print DimPlots side by side
other_cells_clusters_plus_patient_clusters <- other_cells_patient_id_plot + other_cells_chosen_resolution_plot
other_cells_plots_to_save[["other_cells_clusters_plus_patient_clusters"]] <- other_cells_clusters_plus_patient_clusters

# Generate FeaturePlot of other clusters
# max.cutoff q95 is set so any values above the 95th percentile will be set to the 95th percentile value,
# this helps prevent extreme outliers from dominating the color scale
# min.cutoff 0 is set so any positive value will be highlighted
other_cells_feature_plot <- (FeaturePlot(
  object = breast_cancer_patients_other_cells,
  reduction = "umap",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  max.cutoff = "q95",
  min.cutoff = 0,
  label = TRUE) &
  NoAxes()) +
  plot_annotation(title = "Other Cells")
other_cells_plots_to_save[["other_cells_feature_plot"]] <- other_cells_feature_plot

# Other cells cluster tibble column name
stat_col_other_cells_clusters <- "Other cell clusters"
# Calculate statistics for the other cells clusters
other_cells_cluster_statistics <- breast_cancer_patients_other_cells@meta.data %>%
  dplyr::rename(!!sym(stat_col_other_cells_clusters) := !!sym(col_other_cells_chosen_cluster)) %>%
  # Group by patient and cluster, then calculate percentage
  group_by(Patient.ID, !!sym(stat_col_other_cells_clusters)) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Patient.ID) %>%
  mutate(Percentage = Count / sum(Count) * 100) %>%
  ungroup() %>%
  # Ensure Patient.ID is a factor
  mutate(Patient.ID = as.factor(Patient.ID))

# Print tibble with the percentages of cells in each cluster per patient
other_cells_percent_clust_patient <- other_cells_cluster_statistics %>%
  # Specify id_cols so the Count column is dropped
  pivot_wider(names_from = Patient.ID, values_from = Percentage, id_cols = !!sym(stat_col_other_cells_clusters)) %>%
  # Round the values to two decimal places
  mutate(across(2:8, \(x) round(x, 2))) %>%
  # Sort according to the Tumor cluster column
  arrange(!!sym(stat_col_other_cells_clusters))
other_cells_plots_to_save[["other_cells_percent_clust_patient"]] <- other_cells_percent_clust_patient

# Print tibble with the count of cells in each cluster per patient
other_cells_count_clust_patient <- other_cells_cluster_statistics %>%
  # Specify id_cols so the Percentage column is dropped
  pivot_wider(names_from = Patient.ID, values_from = Count, id_cols = !!sym(stat_col_other_cells_clusters)) %>%
  # Replace NA values with 0 so that the total cells per cluster can be calculated
  mutate(across(2:8, ~replace_na(.x, 0))) %>%
  group_by(!!sym(stat_col_other_cells_clusters)) %>%
  mutate(`Tot. clust. cells` = sum(across(where(is.numeric)))) %>%
  ungroup() %>%
  arrange(!!sym(stat_col_other_cells_clusters))
other_cells_plots_to_save[["other_cells_count_clust_patient"]] <- other_cells_count_clust_patient

# Plot the distribution of other cell clusters by patient
other_cells_cluster_distribution_plot <- other_cells_cluster_statistics %>%
  # Plot the data
  ggplot(aes(x = Percentage, y = !!sym(stat_col_other_cells_clusters))) +
  # Add dots for each patient
  geom_point(aes(color = Patient.ID), size = 3, alpha = 0.7) +
  theme_minimal() +
  labs(x = "Percentage of Cells", y = "Cluster", 
       title = "Other Cell Clusters Distribution by Patient",
       color = "Patient") +
  theme(legend.position = "right") +
  scale_color_brewer(palette = "Set1") +
  guides(
    color = guide_legend(order = 1),
  )
other_cells_plots_to_save[["other_cells_cluster_distribution_plot"]] <- other_cells_cluster_distribution_plot

# Identify genes in the SCT assay that start with "KRT"
# These should be the genes that contributes the most to the gene expression
# measured by the antibody panCK
krt_genes <- grep("^KRT", rownames(breast_cancer_patients_other_cells[["SCT"]]), value = TRUE)
# Calculate the average expression of the KRT genes for each cell
krt_avg_expression <- Matrix::colMeans(
  breast_cancer_patients_other_cells[["SCT"]]@data[krt_genes, ])
# Add the average expression as a new metadata column
breast_cancer_patients_other_cells$KRT_Avg_Expression <- krt_avg_expression

# Visualize the co-expression of the KRT genes and the panCK antibody
KRT_panCK_coexpression <- (FeaturePlot(
  breast_cancer_patients_other_cells,
  reduction = "umap",
  max.cutoff = "q95",
  min.cutoff = 0,
  features = c("Mean.PanCK", "KRT_Avg_Expression"),
  blend = TRUE
)  & NoAxes()) + 
  plot_layout(ncol = 2) +
  theme(plot.title = element_text(hjust = 0.5))
KRT_panCK_coexpression[[1]] <-
  KRT_panCK_coexpression[[1]] + 
  labs(title = "PanCK", subtitle = "Mean expression")
KRT_panCK_coexpression[[2]] <-
  KRT_panCK_coexpression[[2]] + 
  labs(title = "KRT genes", subtitle = "Mean expression")
KRT_panCK_coexpression[[3]] <-
  KRT_panCK_coexpression[[3]] + 
  labs(title = "PanCK & KRT genes", subtitle = "Co-expression")
other_cells_plots_to_save[["KRT_panCK_coexpression"]] <- KRT_panCK_coexpression

# Violin plot with the expression of panCK, CD45 and CD68 for each Insitutype clusters
other_cells_clust_protein_expr <- VlnPlot(
  breast_cancer_patients_other_cells,
  assay = "SCT",
  layer = "data",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  pt.size = 0,
  group.by = col_other_cells_chosen_cluster,
  combine = FALSE
)
other_cells_clust_protein_expr <- lapply(
  other_cells_clust_protein_expr,
  function(x) x & NoLegend() & labs(subtitle = "Other Clusters"))
names(other_cells_clust_protein_expr) <- glue('Other_cells_{c("PanCK", "CD45", "CD68")}')
other_cells_plots_to_save <- c(other_cells_plots_to_save, other_cells_clust_protein_expr)

# Calculate the mean of CD45, CD68 and PanCK for each Insitutype cluster
other_cells_cluster_protein_statistics <- breast_cancer_patients_other_cells@meta.data %>%
  group_by(!!sym(col_other_cells_chosen_cluster)) %>%
  summarise(
    `Mean PanCK` = mean(Mean.PanCK),
    `Mean CD45` = mean(Mean.CD45),
    `Mean CD68` = mean(Mean.CD68),
    .groups = "drop"
  ) %>%
  arrange(desc(`Mean PanCK`))
other_cells_plots_to_save[["other_cells_cluster_protein_statistics"]] <- other_cells_cluster_protein_statistics

print(other_cells_plots_to_save)
```

```{r}
#| label: other-cells-save-plots
#| eval: false

# Save the other cells plots
save_data(other_cells_plots_to_save, here(images_dir, "Other cells clusters"))
```

```{r}
#| label: other-cells-save-rds
#| eval: false

# Save the Seurat object
saveRDS(breast_cancer_patients_other_cells, here(objects_dir, "breast_cancer_patients_other_cells.rds"))
```

### Markers

```{r}
#| label: other-cells-markers-read-from-drive

# Load other cells object from memory
other_cells_markers_data <- readRDS(here(objects_dir, "other_cells_markers_data.rds"))
```

```{r}
#| label: other-cells-markers-computation
#| eval: false

# Find all markers of the other clusters
# GSEA needs both positive and negative markers
other_cells_markers_data <- FindAllMarkers(
  breast_cancer_patients_other_cells,
  test.use = "wilcox",
  assay = "SCT",
  only.pos = FALSE,
  random.seed = 5,
  verbose = TRUE)
```

```{r}
#| label: other-cells-markers-save
#| eval: false

# Save the data
saveRDS(other_cells_markers_data, here(objects_dir, "other_cells_markers_data.rds"))
```


```{r}
#| label: other-cells-markers-plots

# List with data to save
other_cells_markers_to_print <- list()

# Filter markers to get the most significant up-regulated ones per cluster
most_significant_other_cells_markers <- other_cells_markers_data %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1 & p_val_adj < 0.05) %>%
  slice_head(n = 10) %>%
  ungroup()
other_cells_markers_to_print[["most_significant_other_cells_markers"]] <- most_significant_other_cells_markers

other_cells_clust_diff_expr_genes_heatmap <- DoHeatmap(
    breast_cancer_patients_other_cells,
    features = most_significant_other_cells_markers$gene,
    assay = "SCT",
    label = TRUE,
    size = 2
    #group.colors = color_lookup_table,
   ) + theme(
     axis.text.y = element_text(size = 5),
   ) + labs(
     title = paste("Other cells clusters"),
     subtitle = "Top 10 Differentially Expressed Genes per Cluster"
   )
other_cells_markers_to_print[["other_clust_diff_expr_genes_heatmap"]] <- other_cells_clust_diff_expr_genes_heatmap

print(other_cells_markers_to_print)
```

```{r}
#| label: other-cells-markers-complex-heatmap

# Unique is used to eliminate duplicated genes, this is done automatically by Seurat DoHeatmap
features <- unique(most_significant_other_cells_markers$gene)

# Extract the expression data for the selected genes from the scaled layer
expr_matrix <- as.matrix(
  GetAssayData(
    breast_cancer_patients_other_cells, 
    layer = "scale.data", 
    assay = "SCT"
  )[
    features,
  ]
)

# Prepare cell type annotations
cell_types <- Idents(breast_cancer_patients_other_cells)
# Create vector with unique and sorted cell types
unique_cell_types <- sort(unique(cell_types))

# Create color palette for cell types
cell_type_colors <- setNames(
  gg_color_hue(length(unique_cell_types)),
  unique_cell_types
)

# Recreate the Seurat expression scale
palette_expression_level = circlize::colorRamp2(
  c(min(expr_matrix), median(expr_matrix), min(2.5, max(expr_matrix))),
  c("#FF00FF", "#000000", "#FFFF00"))

# Create the heatmap with ComplexHeatmap
ht = Heatmap(
  matrix = expr_matrix,
  row_order = features,
  name = "expression",
  column_split = factor(cell_types, levels = unique_cell_types),
  # Do not cluster rows or columns otherwise row_order/column_order are ignored
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  column_title_rot = 0,
  show_column_names = FALSE,
  show_column_dend = FALSE,
  show_row_names = TRUE,
  show_row_dend = FALSE,
  cluster_column_slices = TRUE,
  column_gap = unit(0.5, "mm"),
  row_names_gp = gpar(fontsize = 5),
  # The column title can be either a title for all the columns or a vector with a name for every column
  column_title = unique_cell_types,
  column_title_gp = gpar(fontsize = 7),
  # Add the annotation bars on top
  top_annotation = HeatmapAnnotation(
    # Give a name to the annotation, not used on the actual plot
    name = "Clusters",
    # Annotate the columns
    which = "column",
    # First annotation - clusters
    cluster = cell_types,
    # Second annotation - patients
    patient = breast_cancer_patients_other_cells@meta.data$Patient.ID,
    # Color palettes
    col = list(cluster = cell_type_colors, patient = palette_patients),
    show_legend = c(FALSE, TRUE),
    gap = unit(1, "mm"),
    simple_anno_size = unit(2, "mm"),
    annotation_name_gp = gpar(fontsize = 6)
  ),
  # Color scale for expression
  col = palette_expression_level,
  # Otherwise you get random vertical white lines where there should not be any
  use_raster = FALSE
)
# Put the legends on the right in a single column
draw(ht, merge_legend = TRUE)
```

```{r}
#| label: other-cells-main-markers

# Info to print
main_markers_list <- list()

# Create vector with the main marker from every cluster
main_markers_vector <- most_significant_other_cells_markers %>%
  group_by(cluster) %>%
  dplyr::slice(1) %>%
  ungroup() %>%
  pull(gene)

# Create a feature plot for each marker
main_markers_feature_plot <- FeaturePlot(
  object = breast_cancer_patients_other_cells,
  features = main_markers_vector,
  reduction = "umap"
  ) & 
  NoLegend() &
  NoAxes()

# Create a subtitle for every plot in the patchwork with the number of the cluster
for (i in 1:length(main_markers_vector)) {
  main_markers_feature_plot[[i]] <- main_markers_feature_plot[[i]] + labs(subtitle = glue("cluster {i-1}"))
}

main_markers_list[["main_markers_feature_plot"]] <- main_markers_feature_plot

# Print the info
print(main_markers_list)
```

```{r}
#| label: other-cells-markers-save
#| eval: false

# Other cells markers folder
other_cells_markers_dir <- here(images_dir, "Other cells markers")
# Save the data
save_data(other_cells_markers_to_print, other_cells_markers_dir)
# Save ComplexHeatmap
png(paste(other_cells_markers_dir, "other_cells_complex_heatmap.png", sep="/"),
    width = 15,
    height = 20,
    units = "cm",
    res = 1000)
draw(ht, merge_legend = TRUE)
# Save image
dev.off()
save_data(main_markers_list, other_cells_markers_dir)
```

## All cells

Combine the metadata from the various subsets and print a new UMAP with all the cells

```{r}
#| label: all-cells-metadata-columns

# Name of the metadata column
col_other_cells_ann <- "other_clusters_ann"
col_tumor_cells_ann <- "tumor_clusters_ann"
col_ist_merge_type <- "cell_final_type"
col_ist_merge_group <- "cell_final_group"
```

```{r}
#| label: all-cells-metadata-add

# Create metadata column distinguishing between tumor and other (unknown) cells
# Cluster 7 is annotated as unknown as it is not 100% clear if it is a tumor cluster
breast_cancer_patients_other_cells@meta.data %<>%
  mutate("{col_other_cells_ann}" := case_match(
  get(col_other_cells_chosen_cluster),
  "7" ~ "Unknown",
  .default = "Tumor",
))

# Create metadata column with all the tumor subclusters
breast_cancer_patients_other_cells@meta.data %<>%
  mutate("{col_tumor_cells_ann}" := case_match(
  get(col_other_cells_ann),
  "Tumor" ~ glue("Tumor {get(col_other_cells_chosen_cluster)}"),
  .default = .data[[col_other_cells_ann]],
))

## CELL TYPES

# Add other cells clusters to analyze object
breast_cancer_patients_analyze <- AddMetaData(
  object = breast_cancer_patients_analyze,
  metadata = FetchData(
    object = breast_cancer_patients_other_cells,
    vars = col_other_cells_ann),
  col.name = col_other_cells_ann
)

# Merge the other cells clusters with the insitutype clusters
breast_cancer_patients_analyze@meta.data %<>%
mutate("{col_ist_merge_type}" := if_else(
    get(col_ist_ann) != "Other",
    get(col_ist_ann),
    get(col_other_cells_ann)
))

# Merge the ist cells groups with the tumor groups
breast_cancer_patients_analyze@meta.data %<>%
mutate("{col_ist_merge_group}" := if_else(
    get(col_cell_group) != "Other",
    get(col_cell_group),
    get(col_other_cells_ann)
))
```

```{r}
#| label: all-cells-plot

# List to save data
all_cells_images <- list()

# Print UMAP with final cell types
all_cell_types_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_ist_merge_type,
  reduction = "sct_umap_patients",
  cols = palette_cell_types) +
  labs(title = "Insitutype clusters") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      ncol=1,
      keywidth = unit(0.5, "lines"),
      keyheight = unit(0.8, "lines"),
      spacing = unit(0.2, "lines"))
  ) +
  theme_classic(base_size = 9) &
  NoAxes()
all_cells_images[["all_cell_types_sct_plot"]] <- all_cell_types_sct_plot

# Print UMAP with final cell groups
all_cell_groups_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_ist_merge_group,
  reduction = "sct_umap_patients",
  cols = palette_cell_types) +
  labs(title = "Final cell groups") &
  NoAxes()
all_cells_images[["all_cell_groups_sct_plot"]] <- all_cell_groups_sct_plot

# Tibble with mean protein data for the cell groups
all_cell_mean_proteins <- breast_cancer_patients_analyze@meta.data %>%
  group_by(!!sym(col_ist_merge_group)) %>%
  summarise(
    `Mean PanCK` = mean(Mean.PanCK),
    `Mean CD45` = mean(Mean.CD45),
    `Mean CD68` = mean(Mean.CD68),
    .groups = "drop"
  )
all_cells_images[["all_cell_mean_proteins"]] <- all_cell_mean_proteins

plot_proteins_all_cells <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "SCT",
  layer = "data",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  pt.size = 0,
  group.by = col_ist_merge_group,
  cols = palette_cell_types,
  combine = FALSE
)
plot_proteins_all_cells <- lapply(
  plot_proteins_all_cells,
  function(x) x & NoLegend() & labs(subtitle = "Cell groups"))
names(plot_proteins_all_cells) <- glue('Final_groups_{c("PanCK", "CD45", "CD68")}')
all_cells_images <- c(all_cells_images, plot_proteins_all_cells)

print(all_cells_images)
```

```{r}
#| label: all-cells-save-data
#| eval: false

# Save the data
save_data(all_cells_images, here(images_dir, "All cells annotated"))
```

## Gene Set Enrichment Analysis

### GSEA objects

```{r}
#| label: gsea-load-objects

# Load the GSEA results
GSEA_results <- readRDS(here(objects_dir, "GSEA_results.rds"))
```

```{r}
#| label: gsea-create-objects
#| eval: false

# Set default assay to RNA
DefaultAssay(breast_cancer_patients_other_cells) <- "RNA"

# Set the colors for the p adjust gradient bar
max_color <- rgb(238, 197, 194, maxColorValue = 255)
min_color <- rgb(215, 102, 86, maxColorValue = 255)
options(enrichplot.colours = c(min_color, max_color))

# List to save the GSEA results
GSEA_results <- list()
# Run GSEA for each tumor cluster
for (cluster in levels(breast_cancer_patients_other_cells)) {
  tumor_cluster_number <- cluster
  print(paste("Running GSEA analysis for cluster:", tumor_cluster_number))
  
  # Get the markers for the tumor cluster
  other_cells_cluster_markers <- other_cells_markers_data %>%
    dplyr::filter(cluster == tumor_cluster_number)
  
  # How to create the gene list
  # http://yulab-smu.top/biomedical-knowledge-mining-book/faq.html#genelist
  # Gene list creation
  gsea_gene_list <- other_cells_cluster_markers %>%
    dplyr::mutate(rank = rank(avg_log2FC, ties.method = "random")) %>%
    dplyr::arrange(desc(rank)) %>%
    with(setNames(avg_log2FC, gene))
  
  # Run GSEA
  gsea <- gseGO(geneList     = gsea_gene_list,
                    keyType      = "SYMBOL",
                    OrgDb        = org.Hs.eg.db, 
                    ont          = "BP",
                    minGSSize    = 10,
                    maxGSSize    = 500,
                    pvalueCutoff = 0.05,
                    verbose      = TRUE,
                    pAdjustMethod = "fdr")
  # Save the GSEA results
  GSEA_results[[tumor_cluster_number]] <- gsea
}

# Save the GSEA results
saveRDS(GSEA_results, here(objects_dir, "GSEA_results.rds"))
```

### GSEA plots

```{r}
#| message: false
#| warning: false
#| fig-width: 9
#| fig-height: 6
# Disable messages and warnings so they do not appear above the first image generated by the loop
# Make images bigger so they are easier to read

# Create a list of gene counts for each cluster
cluster_gene_stats <- list()
for (cluster in levels(breast_cancer_patients_other_cells)) {
  tumor_cluster_markers <- other_cells_markers_data %>%
    dplyr::filter(cluster == !!cluster)
  
  # Calculate gene counts and save them in a list
  cluster_gene_stats[[cluster]] <- list(
    num_upreg_genes = tumor_cluster_markers %>%
      dplyr::filter(avg_log2FC > 0, p_val < 0.05) %>%
      nrow(),
    num_downreg_genes = tumor_cluster_markers %>%
      dplyr::filter(avg_log2FC < 0, p_val < 0.05) %>%
      nrow()
  )
}

# Lists to save plots and tibbles
GSEA_plots <- list()
GSEA_tibbles <- list()

GSEA_to_plot <- list()
# GSEA plots with results
for (cluster in names(GSEA_results)) {
  gsea <- GSEA_results[[cluster]]
  # If there are results
  if (nrow(gsea@result) > 0) {
    GSEA_to_plot[[cluster]] <- GSEA_results[[cluster]]
  }
}
# Print the names of the clusters with GSEA results
print(names(GSEA_to_plot))

# Simplify values for the GSEA plots
GSEA_plot_simply_cutoff <- c(
  "4" = 0.5,
  "5" = 0.5,
  "8" = 1)
# Create plots and tibbles
# Do not plot if no pathways have been found
for (cluster in names(GSEA_to_plot)) {
  gsea <- GSEA_to_plot[[cluster]]
  # Simplify GSEA results by grouping together or eliminating terms that are very similar or redundant
  gsea_simplified <- clusterProfiler::simplify(gsea, cutoff = GSEA_plot_simply_cutoff[[cluster]])
  gene_stats <- cluster_gene_stats[[cluster]]
  num_upreg_genes <- gene_stats$num_upreg_genes
  num_downreg_genes <- gene_stats$num_downreg_genes
  
  # Prepare plot labels
  GSEAlabels <- labs(
    title = paste("Significant Pathways in Tumor Cluster", cluster), 
    subtitle = "by Gene Set Enrichment Analysis",
    caption = paste0("Based on ", num_upreg_genes, " up-regulated genes and ", num_downreg_genes, " down-regulated genes.")
  )
  # Prepare plot aesthetics
  GSEAtheme <- theme(
    plot.title = element_text(hjust = 0.5, size = 20),
    plot.subtitle = element_text(hjust = 0.5, size = 15),
    axis.text.x = element_text(angle = 0, size = 10),
    axis.text.y = element_text(angle = 0, size = 6)
  ) 
  # Make the GSEA plot
  GSEADotPlot <- dotplot(gsea_simplified, showCategory = 25) +
    GSEAlabels + labs(x = "Gene Ratio", y = "Biological Pathway") +
    GSEAtheme
  
  # Save the plot and tibble
  GSEA_plots[[glue("GSEA Tumor cluster {cluster}")]] <- GSEADotPlot
  GSEA_tibbles[[glue("GSEA Tumor cluster {cluster}")]] <- as_tibble(gsea_simplified@result)
}
```

```{r}
#| label: gsea-plots

# Display the GSEA plots
print(GSEA_plots)
```

```{r}
#| label: gsea-tibbles

# Display the GSEA tibbles
print(GSEA_tibbles)
```

```{r}
#| label: gsea-save
#| eval: false

# Save the GSEA plots
save_data(GSEA_plots, here(images_dir, "GSEA plots"))
# Save the GSEA tibbles
save_data(GSEA_tibbles, here(images_dir, "GSEA tables"))
# Save the GSEA results
saveRDS(GSEA_results, here(objects_dir, "GSEA_results.rds"))
```


## Merge

Merge normal and tumor subclusters

```{r}
#| label: merge-cells-metadata-columns

# Name of metadata column with all cell types and tumor subtypes
col_cell_tumor_cluster_subtype <- "cell_final_subtype"
```

```{r}
#| label: merge-cells-metadata-add
#| eval: false

# Copy the metadata for the tumor cells
breast_cancer_patients_analyze <- AddMetaData(
  object = breast_cancer_patients_analyze,
  metadata = FetchData(
    object = breast_cancer_patients_other_cells,
    vars = col_tumor_cells_ann),
  col.name = col_tumor_cells_ann
)


# Merge the insitutype phenotyping with the tumor clusters
breast_cancer_patients_analyze@meta.data %<>%
  mutate("{col_cell_tumor_cluster_subtype}" := if_else(
    get(col_ist_ann) != "Other",
    get(col_ist_ann),
    get(col_tumor_cells_ann)
    )
  )
```

```{r}
#| label: merge-cells-info

# Vector with cell subtypes
cell_subtypes <- unique(breast_cancer_patients_analyze@meta.data[[col_cell_tumor_cluster_subtype]])

# Print the number of cell phenotypes including tumor subtypes
print(glue("Cell phenotypes (Insitutype + Tumor clusters):"))
print(cell_subtypes)
print(glue("Number: {length(cell_subtypes)}"))
```

## Spatial plots of clusters

Plot the spatial distribution of the cell types and label them according to the normal/tumor clusters where they belong.

```{r}
#| label: spatial-clusters-plots

# Count the number of tumor clusters by looking at the column "col_ist_merge_type" and counting the number of unique cluster names that starts with tumor
num_tumor_clusters <- length(grep("^Tumor", unique(breast_cancer_patients_analyze@meta.data[[col_cell_tumor_cluster_subtype]])))
# Create a gray scale for the tumor clusters
tumor_clusters_colors <- gray.colors(12, start = 0.2, end = 0.9)
# Create the color palette for the niches
cells_all_phenotypes_color_palette <- generate_colors_lookup_table(
  breast_cancer_patients_analyze,
  cluster_column_name = col_cell_tumor_cluster_subtype,
  known_clusters_colors = palette_cell_types,
  color_palette = tumor_clusters_colors)
# Create the plots with the cell types for every stamp
cell_types_stamps_plots <- generate_spatial_plots(
  breast_cancer_patients_analyze,
  cluster_var = col_cell_tumor_cluster_subtype,
  cluster_name = "Cell types with tumor subclusters",
  legend_fill = "Cell types",
  color_lookup_table = cells_all_phenotypes_color_palette)
# Display the plots
print(cell_types_stamps_plots)
```

```{r}
#| eval: false

# Save the plots
save_data(cell_types_stamps_plots, here(images_dir, "Stamps_with_clusters"))
```

## Spatial niches

### Build niches

```{r}
#| label: build-niches-params

# To build the niche assay, Seurat uses only the spatial images and the cell phenotypes (a column from the metadata)
# Number of niche to calculate
niches_nums <- c(6, 9, 12, 15)
```

```{r}
#| label: build-spatial-niches
#| eval: false

# Build the niche assays
for (num in niches_nums) {
  # Print the current number of niches being calculated
  print(glue("Calculating {num} niches"))
  # Build the niche assay
  breast_cancer_patients_analyze <- BuildNicheAssay(
    object = breast_cancer_patients_analyze,
    fov = "LU001FFP03",
    group.by = col_cell_tumor_cluster_subtype,
    assay = glue("niches{num}"),
    cluster.name = glue("niches_{num}"),
    # Number of niches to find, default is 4
    niches.k = num,
    # Number of neighbors to consider, default is 20
    # Very small neighborhoods produce sparse and noisy data
    # Very large neighborhoods become inaccurate representations of a cells 3D surroundings:
    # the area of your circular neighborhood increases with the square of the radius,
    # but the volume of the corresponding (unobserved) 3D tissue 
    # region increases with the cube of the radius.
    # This means that the larger the radius, the less of your 3D neighborhood falls in
    # the narrow tissue slide youve assayed, and the more it consists of unseen cells
    # increasingly far away in the Z-dimension.
    neighbors.k = 30
  )
}
```

```{r}
#| eval: false

# Save the object
saveRDS(breast_cancer_patients_analyze, here(objects_dir, "breast_cancer_patients_analyze.rds"))
```

### Setup spatial niches study

```{r}
#| label: spatial-niches-study-setup

# Number of niches to plot
niches_plot <- niches_nums[3]
# Metadata column with the niches to plot
col_niches_plot <- glue("niches_{niches_plot}")

# Metadata column with the highest number of niches
col_highest_niches_num <- glue("niches_{niches_nums[length(niches_nums)]}")
# Create the color palette for the niches
niches_color_palette <- generate_colors_lookup_table(
  breast_cancer_patients_analyze,
  cluster_column_name = col_highest_niches_num,
  color_palette = brewer.pal(12, name = "Set3"))
```

### Spatial plots of niches

```{r}
#| label: spatial-niches-plots

# Create the plots with the niches for every stamp
niches_stamps_plots <- generate_spatial_plots(
  breast_cancer_patients_analyze,
  cluster_var = col_niches_plot,
  cluster_name = "Seurat niches",
  legend_fill = "Niches",
  color_lookup_table = niches_color_palette)
# Display the plots
print(niches_stamps_plots)
```

```{r}
#| eval: false

# Save the plots
save_data(niches_stamps_plots, here(images_dir, glue("Stamps_with_{niches_plot}_niches")))
```

### Statistics about niches

```{r}
#| label: niches-statistics-calc

# Create list to save data
niches_statistics_calc <- list()

# Count and calculate percentages of cell types inside every niche
# The percentages of the various cells types in a niches adds up to 100%
cell_type_counts <- breast_cancer_patients_analyze@meta.data %>%
  group_by(!!sym(col_niches_plot), !!sym(col_cell_tumor_cluster_subtype)) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count / sum(count)) * 100) %>%
  arrange(.by_group = TRUE)
# Print the cell type counts and percentages
niches_statistics_calc[["cell_type_counts"]] <- cell_type_counts

# Get the list of unique niches
niches <- sort(unique(breast_cancer_patients_analyze@meta.data[[col_niches_plot]]))
# Print the niches
print(sort(niches))

# Create list to save niches data
niches_data <- list()

# Loop through each niche and calculate the data for the plot
for (niche in niches) {
  
  # Set the cutoff value for the percentage
  niche_cell_type_cutoff <- 2
  # Filter out cells in other niches and group the cells types below the cutoff together
  niche_stat <- cell_type_counts %>%
    dplyr::filter(!!sym(col_niches_plot) == niche) %>%
    dplyr::mutate(
      !!sym(col_cell_tumor_cluster_subtype) := ifelse(
        percentage >= niche_cell_type_cutoff,
        !!sym(col_cell_tumor_cluster_subtype),
        "Others")
    ) %>%
    dplyr::group_by(!!sym(col_cell_tumor_cluster_subtype), !!sym(col_niches_plot)) %>%
    dplyr::summarize(
      percentage = sum(percentage, na.rm = TRUE),
      count = sum(count, na.rm = TRUE),
      .groups = "drop"
    )
  niches_data[[glue("Niche_{niche}_statistics")]] <- niche_stat
}
# Add niches data to print list
niches_statistics_calc <- c(niches_statistics_calc, niches_data)

print(niches_statistics_calc)
```

```{r}
#| label: niches-statistics-plots

# Create list to save data
niches_statistics_plots <- list()

# Loop through each niche and create a bar plot
for (niche in niches) {
  
  # Extract niche data
  niche_data <- niches_data[[niche]]

  # Create the bar plot
  niche_barplot <- niche_data %>%
    ggplot(aes(
      x = !!sym(col_cell_tumor_cluster_subtype),
      y = percentage,
      fill = !!sym(col_cell_tumor_cluster_subtype)
    )) +
    geom_bar(stat = "identity") +
    geom_text(
      aes(label = count),
      vjust = -0.3,
      color = "black",
      size = 3.5
    ) +
    labs(
      title = glue("Niche: {niche} of {niches_plot}"),
      subtitle = "Cell Type Distribution",
      caption = glue(
        "Cutoff value: {niche_cell_type_cutoff}%, the cells types with a percentage below the cutoff are grouped together as 'Others'.
        The percentage of each cell type represents its proportion within the niche, with all percentages summing to 100%.
        The count number above the bars represents the number of cells of each type."
      ),
      x = "Cell Type",
      y = "Percentage (%)"
    ) +
    # Make space for the count number above the bars
    expand_limits(y = max(niche_data$percentage) * 1.04) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          # Move caption to the left
          plot.caption = element_text(hjust = 0)) +
    scale_fill_manual(values = cells_all_phenotypes_color_palette) +
    NoLegend()

  # Add the plot to the list
  niches_statistics_plots[[glue::glue("Niche_{niche}_barplot")]] <- niche_barplot
}

# Display all niches bar plots
print(niches_statistics_plots)
```

```{r}
#| label: niches-patients-statistics

# Create list to save data
niches_patient_data <- list()

# Count and calculate percentage of cell types per niche
niches_patient_counts <- breast_cancer_patients_analyze@meta.data %>%
  mutate("{col_niches_plot}" := factor(!!sym(col_niches_plot), levels = sort(unique(!!sym(col_niches_plot)))),
         Patient.ID = factor(Patient.ID)) %>%
  group_by(Patient.ID, !!sym(col_niches_plot)) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count / sum(count)) * 100) %>%
  arrange(Patient.ID, .by_group = TRUE)
# Add to list
niches_patient_data[["niches_patient_counts"]] <- niches_patient_counts

# Create the bar plot
niches_patient_dotplot <- ggplot(niches_patient_counts,
                                 aes(x = Patient.ID, y = percentage, color = !!sym(col_niches_plot))) +
  geom_rect(data = unique(niches_patient_counts["Patient.ID"]),
            aes(xmin = as.numeric(Patient.ID) - 0.4,
                xmax = as.numeric(Patient.ID) + 0.4,
                ymin = -Inf, ymax = Inf),
            fill = "grey90", alpha = 0.3, inherit.aes = FALSE) +
  geom_point(size = 3, position = position_dodge(width = 0.7)) +
  labs(title = paste("Niches distribution across patients"),
       x = "Patient",
       y = "Percentage (%)") +
  guides(color = guide_legend(title = "Niche")) +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1)) +
  scale_color_manual(values = niches_color_palette)
# Add to list
niches_patient_data[["niches_patient_dotplot"]] <- niches_patient_dotplot

# Print the list
print(niches_patient_data)
```

```{r}
#| eval: false

# Folder name
stat_niches_dir <- glue("Statistics_{niches_plot}_niches")
# Save the plots
save_data(niches_statistics_calc, here(images_dir, stat_niches_dir))
save_data(niches_statistics_plots, here(images_dir, stat_niches_dir))
save_data(niches_patient_data, here(images_dir, stat_niches_dir))
```

## CellChat

```{r}
#| label: load-cellchat

# Load cellchat object
cellchat <- readRDS(here(objects_dir, "cellchat.rds"))
```

```{r}
#| label: cellchat
#| eval: false

# Genes should be in rows with rownames and cells in columns with colnames
# Normalized data (e.g., library-size normalization and then log-transformed with a pseudocount of 1) is required
# The SCT assay should be fine as it is used in the following vignette:
# https://htmlpreview.github.io/?https://github.com/jinworks/CellChat/blob/master/tutorial/CellChat_analysis_of_spatial_transcriptomics_data.html
data.input = Seurat::GetAssayData(
  breast_cancer_patients_analyze,
  layer = "data",
  assay = "SCT")

# Spatial locations of spots from full (NOT high/low) resolution images are required
spatial.locs = Seurat::GetTissueCoordinates(
  object = breast_cancer_patients_analyze,
  image = "LU001FFP03",
) %>%
# Set the rownames equal to the cell names and remove the cell column
  tibble::column_to_rownames(var = "cell")

# For CosMx data, the spatial coordinates are in pixels and the conversion factor can be found in the NanoString documentation:
# https://nanostring-biostats.github.io/CosMx-Analysis-Scratch-Space/posts/flat-file-exports/flat-files-compare.html
# Because CosMx does not include the uniform cell size, users can compute the minimum cell centroid-to-centroid distance via computeCellDistance and use its half value as the tolerance factor.
# CellChat does not need an accurate tolerance factor, which is used for determining whether considering the cell-pair as spatially proximal if their distance is greater than interaction.range but smaller than interaction.range + tol.
conversion.factor = 0.12028
distance_matrix = computeCellDistance(
  coordinates = spatial.locs,
  # to convert the distance from pixels to micrometers
  ratio = conversion.factor)
median_cell_distance = median(distance_matrix)
spot.size = min(distance_matrix)
spatial.factors = data.frame(ratio = conversion.factor, tol = spot.size/2)

cellchat <- createCellChat(
  # A normalized (NOT count) data matrix (genes by cells)
  object = data.input,
  # A data frame (rows are cells with rownames) consisting of cell information used for defining cell groups
  meta = breast_cancer_patients_analyze@meta.data,
  # A char name of the variable in meta data, defining cell groups
  group.by = col_ist_merge_type,
  datatype = "spatial",
  # A data matrix in which each row gives the spatial locations/coordinates of each cell
  coordinates = spatial.locs,
  # A data frame containing two distance factors 'ratio' and 'tol', which is dependent on spatial transcriptomics technologies
  spatial.factors = spatial.factors,
  do.sparse = TRUE)

# SET THE DATABASE TO BE USED
# Ligand-receptor interactions in CellChat database for human
CellChatDB <- CellChatDB.human
# Show the description of CellChatDB databse
showDatabaseCategory(CellChatDB)
# Use all CellChatDB except for "Non-protein Signaling" for cell-cell communication analysis
CellChatDB.use <- subsetDB(CellChatDB, non_protein = FALSE)
# Set the used database in the object
cellchat@DB <- CellChatDB.use

# Subset the expression data of signaling genes for saving computation cost
# This step is necessary even if using the whole database
cellchat <- subsetData(cellchat)

# Identify over-expressed signaling genes associated with each cell group
cellchat <- identifyOverExpressedGenes(
  object = cellchat,
  # Only return positive markers
  only.pos = TRUE,
  # whether to return the object
  # otherwise return a data frame consisting of over-expressed signaling genes associated with each cell group
  return.object = TRUE,
  # Threshold of the fraction of cells expressed in one cluster
  thresh.pc = 0,
  # Threshold of the log fold change values
  thresh.fc = 0,
  # Threshold of p-values
  thresh.p = 0.05,
  # the minimum number of expressed cells required for the genes that are considered for cell-cell communication analysis
  min.cells = 10)

# Identify over-expressed ligand-receptor interactions (pairs) within the used CellChatDB
cellchat <- identifyOverExpressedInteractions(
  object = cellchat,
  # Set if it is required that both ligand and receptor from one pair are over-expressed
  variable.both = TRUE,
  # Whether returning a CellChat object
  # If FALSE, it will return a data frame containing the over-expressed ligand-receptor pairs
  return.object = TRUE)

# Use a diffusion process to smooth genes expression values based on their neighbors defined in a high-confidence experimentally validated protein-protein network
# The smoothed data is also called "projected" because it is generated through a process that predicts or estimates missing or unobserved values in the dataset
# The term "projected" highlights the idea that the smoothed data is not strictly observed but is inferred or extrapolated from the existing raw data, using statistical or computational models
# This projection helps overcome technical limitations like dropout effects in single-cell RNA sequencing, especially when sequencing depth is shallow
cellchat <- smoothData(
  object = cellchat,
  # Adjacency matrix of protein-protein interaction network to use
  adj = PPI.human,
  # Numeric in [0,1] alpha = 0: no smoothing
  # A larger value alpha results in increasing levels of smoothing
  alpha = 0.5)

# Compute the communication probability/strength between any interacting cell groups
cellchat <- computeCommunProb(
  object = cellchat,
  # Methods for computing the average gene expression per cell group
  type = "triMean",
  # Whether use the raw data (i.e., 'object@data.signaling') or the smoothed data (i.e., 'object@data.smooth')
  # Set it to false because of the low sequencing depth of the data being analyzed
  raw.use = FALSE,
  # Whether consider the proportion of cells in each group across all sequenced cells
  # Set it to true as the dataset reflects the natural abundance of different cell types in the sample
  population.size = FALSE,
  # Whether to use distance constraints to compute communication probability
  # Set to true to make communication probability inversely proportional to the computed distance
  distance.use = TRUE,
  # The maximum interaction/diffusion length of ligands (Unit: microns)
  # This hard threshold is used to filter out the connections between spatially distant regions
  interaction.range = 250,
  scale.distance = 0.1,
  # The minimum number of interacting cell pairs required for defining spatially proximal cell groups
  k.min = 10,
  contact.dependent = TRUE,
  contact.range = 10,
  # Whether use the raw data (i.e., 'object@data.signaling') or the smoothed data (i.e., 'object@data.smooth')
  raw.use = TRUE)

# Filter out the cell-cell communication if there are only few cells in certain cell groups
cellchat <- filterCommunication(cellchat, min.cells = 10)
# Compute the communication probability on signaling pathway level by summarizing the communication probabilities of all ligands-receptors interactions associated with each signaling pathway
cellchat <- computeCommunProbPathway(cellchat)
# Calculate the aggregated cell-cell communication network by counting the number of links or summarizing the communication probability
cellchat <- aggregateNet(cellchat)

png(filename=here("cellchat_test.png"), width = 15, height = 20, units = "cm", res = 1000)
netVisual_circle(cellchat@net$count, vertex.weight = rowSums(cellchat@net$count), weight.scale = T, label.edge= F, title.name = "Number of interactions", margin = 0.2, vertex.label.cex = 0.8)
dev.off()
netVisual_circle(cellchat@net$weight, vertex.weight = rowSums(cellchat@net$weight), weight.scale = T, label.edge= F, title.name = "Interaction weights/strength")

netVisual_heatmap(cellchat, measure = "count", color.heatmap = "Blues")
netVisual_heatmap(cellchat, measure = "weight", color.heatmap = "Blues")

# Examine the signaling sent from each cell group
# Set the parameter edge.weight.max so that edge weights are comparable between differet networks
group_size <- as.numeric(table(cellchat@idents))
cellchat_weight_mat <- cellchat@net$weight
par(mfrow = c(3,4), xpd=TRUE)
for (i in 1:nrow(cellchat_weight_mat)) {
  # Create new matrix with the same dimensions and names as the oroginal, but all elements are initialized to 0
  cellchat_type_weight_mat <- matrix(0, nrow = nrow(cellchat_weight_mat), ncol = ncol(cellchat_weight_mat), dimnames = dimnames(cellchat_weight_mat))
  # Fills the i-th row of the new matrix with the corresponding i-th row of the original matrix, all other rows in the new matrix remain zero
  cellchat_type_weight_mat[i, ] <- cellchat_weight_mat[i, ]
  # Visualizes the i-th row of interaction weights
  netVisual_circle(
    net = cellchat_type_weight_mat,
    # Specify the size of the vertices (nodes) in the network
    vertex.weight = group_size,
    # Scales the edge weights (connection thickness) in the plot
    weight.scale = T,
    # Set the maximum edge weight (thickness) to the largest value in the original matrix
    edge.weight.max = max(cellchat_weight_mat),
    # Add a title to the plot using the name of the i-th row of matrix
    title.name = rownames(cellchat_weight_mat)[i])
}
```