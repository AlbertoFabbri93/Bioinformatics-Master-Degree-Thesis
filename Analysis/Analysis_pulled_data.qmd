---
title: "A study on brain metastases from primary breast cancer"
author: "Alberto Fabbri"
format: html
editor_options: 
  chunk_output_type: inline
---

# Brain metastaes from primary breast cancer

This study aims to investigate the immune microenvironment of brain metastases from primary breast cancer. The analysis is performed on NanoString data from 7 patients.

## Set up the environment

### Packages

This analysis uses `renv` to manage the dependencies. `renv` is a normal R package that can be installed with:

`install.packages("renv")`

Once `renv` is installed it can be used to install the necessary packages by running the following code:

`renv::restore()`

`renv` will then proceed to install all the packages specified in the `renv.lock` file.

**Do not update the version of the packages if not absolutely necessary.**

If some packages have been update, run `renv::snapshot()` to update the `renv.lock` file.

### Quarto

To run this file it is necessary to have `quarto` installed. `quarto` is a software used to create reproducible documents that embed code. It can be installed by downloading it from the official website:

[https://quarto.org]

::: {.content-hidden}
### Load the necessary packages
:::

```{r}
#| label: setup
#| include: false

# Work with single cell and spatial omics data
library("Seurat")

# The future package is not supported in Seurat v5
# # Do not import these future symbols because they conflict with the zeallot package
# library (future, exclude = c("%->%", "%<-%"));
# # Parallelize the computation with several worker processes that will run in their own R session
# plan("multisession", workers = 6)
# # Set the maximum size of the future globals
# options(future.globals.maxSize = 6.5 * 2^30)
# # Ensure proper random number seeding globally
# options(future.seed = TRUE)

###### TIDYVERSE ######
# Data manipulation
library("dplyr")
# Create nice plots
library("ggplot2")
# Open Excel files
library("readxl")
# Open CSV files
library("readr")
# Better dataframes
library("tibble")
# Pivot tibbles
library("tidyr")

# Unpack multiple values without temporary variables
library("zeallot")
# Add interpreted string literals
library("glue")
# Machine learning library from NanoString
library("InSituType")
# Used for the barplots
library("dittoSeq")
# Used to visualize the raw images from AtoMx
library("EBImage")
# For faster estimation when using SCTransform
library("glmGamPoi")
# For fast Wilcoxon rank sum test
library("presto")
# Combine multidimensional arrays into a single array
library("abind")
# Sparse and dense matrix classes and methods
library("Matrix")
# Analysis of cell-cell communication
library("CellChat")

## PLOTTING
# Used to annotate images with multiple plots
library("patchwork")
# Used to arrange plots in a common grid
library("ggpubr")
# Extension of ggplot2 supporting relational data structures such as networks, graphs, and trees
library("ggraph")
# Used to plot the cluster tree created by running FindClusters at several resolutions
library("clustree")
# Add more layout options to ggplot
library("ggforce")
# More complex heatmaps
library("ComplexHeatmap")
# Print table as interactive HTML widget
library("DT")
# Additional color palettes
library("RColorBrewer")
library("pals")
library("circlize")

## GENE SET ENRICHMENT ANALYSIS
# Used to perform gene set enrichment analysis
library("clusterProfiler")
# Database with the gene information
library("org.Hs.eg.db")
# List all supported types
keytypes(org.Hs.eg.db)

# Make every conflict trigger an error
library("conflicted")

# Import custom written functions
source(file.path(gl_source_files_dir, "Utils.R"))
source(file.path(gl_source_files_dir, "Plotting.R"))
source(file.path(gl_source_files_dir, "Color_palettes.R"))
source(file.path(gl_source_files_dir, "Reference_profiles.R"))

# Create object folder if it does not exist
if (!dir.exists(gl_obj_dir)) {
  dir.create(gl_obj_dir)
}
```

## Tidy Seurat object

### Separate assays

The NanoString data is stored in a single assay. The data is divided into three groups: gene expression, negative probes, and system control. The system control and negative probes are not used in the downstream analysis. The gene expression data is moved to a new assay called "RNA". The system control and negative probes are moved to new assays called "SystemControl" and "NegativeProbes", respectively. The metadata is cleaned by removing unnecessary columns and renaming others. The images are copied from the original Seurat object to a new one. The assay name in the images is updated to match the new assay name.

```{r}
#| label: load-cleaned-object

# Load cleaned object from memory
breast_cancer_patients <- readRDS(file.path(gl_obj_dir, "breast_cancer_patients.rds"))
```

```{r}
#| label: create-clenaed-object
#| eval: false

# Load the original Seurat object
breast_cancer_patients_mixed_features <- readRDS(file.path(gl_root_dir, "Analysis", "breast.cancer.patients.original.rds"))

tidy_seurat_object_assay <- function(seurat_object_mixed_features, assay_name) {

  assay <- seurat_object_mixed_features[[assay_name]]
  
  # Extract features for the "Gene", "Negative Probes" and "System Control" assays
  system_control_features <- grep("^SystemControl", rownames(assay), value = TRUE)
  negative_probes_features <- grep("^Negative", rownames(assay), value = TRUE)
  gene_features <- dplyr::setdiff(rownames(assay), c(system_control_features, negative_probes_features))
  
  # Subset the count data for the various groups of features
  system_control_counts <- assay$counts[system_control_features, ]
  negative_probes_counts <- assay$counts[negative_probes_features, ]
  gene_counts <- assay$counts[gene_features, ]
  
  # Create new Assay objects with the respective features
  system_control_assay <- CreateAssay5Object(counts = system_control_counts)
  negative_probes_assay <- CreateAssay5Object(counts = negative_probes_counts)
  gene_assay <- CreateAssay5Object(counts = gene_counts)
  
  # Assay names
  sytem_control_assay_name <- "SystemControl"
  negative_probes_assay_name <- "NegativeProbes"
  gene_assay_name <- "RNA"
  
  # Set appropriate keys for the new assays
  system_control_assay@key <- paste0(sytem_control_assay_name, "_")
  negative_probes_assay@key <- paste0(negative_probes_assay_name, "_")
  gene_assay@key <- paste0(gene_assay_name, "_")
  
  # Create a new Seurat object
  seurat_object_cleaned_features <- CreateSeuratObject(counts = gene_assay)
  seurat_object_cleaned_features[["SystemControl"]] <- system_control_assay
  seurat_object_cleaned_features[["NegativeProbes"]] <- negative_probes_assay
  
  original_metadata <- seurat_object_mixed_features@meta.data
  
  # Specify the metadata columns to exclude
  exclude_cols <- c(
    "orig.ident",
    "nCount_Nanostring",
    "nFeature_Nanostring",
    "nn_b326beb0.2706.4f9e.a165.44afc025b72e_1_cluster_cluster_7a2d0841.7221.45b3.be66.f38ce260c6aa_1",
    "RNA_nbclust_419c19f2.965d.4b31.822e.6eba63b75b54_1_clusters",
    "RNA_nbclust_419c19f2.965d.4b31.822e.6eba63b75b54_1_posterior_probability",
    "cell",
    "nCount_RNA",
    "nFeature_RNA",
    "nCount_negprobes",
    "nFeature_negprobes",
    "Panel",
    "cellSegmentationSetId",
    "cellSegmentationSetName")

  # Remove the specified columns
  filtered_metadata <- original_metadata[, !(colnames(original_metadata) %in% exclude_cols)]
  
  # Rename one metadata column
  colnames(filtered_metadata)[which(colnames(filtered_metadata) == "cell_id")] <- "full_cell_ID"

  # Copy the metadata from the original Seurat object
  seurat_object_cleaned_features <- AddMetaData(object = seurat_object_cleaned_features, metadata = filtered_metadata)
  
  # Copy the images from the original Seurat object
  seurat_object_cleaned_features@images <- seurat_object_mixed_features@images
  # Replace the assay name with the new one
  for (image_key in names(seurat_object_cleaned_features@images)) {
    seurat_object_cleaned_features@images[[image_key]]@assay <- gene_assay_name
  }

  return(seurat_object_cleaned_features)
}

# Separate the assays in the Seurat object
breast_cancer_patients <- tidy_seurat_object_assay(breast_cancer_patients_mixed_features, "Nanostring")

# Save the cleaned object
saveRDS(breast_cancer_patients, file.path(gl_obj_dir, "breast_cancer_patients.rds"))
```

### Filter out anomalous cells

```{r}
#| label: load-filtered-cells-object

# Load filtered cells object from memory
breast_cancer_patients_filt_cells <- readRDS(file.path(gl_obj_dir, "breast_cancer_patients_filt_cells.rds"))
```

```{r}
#| label: create-filtered-cells-object
#| eval: false

# Read csv file with cells to remove from Seurat object
cells_to_remove <- read_csv(
  file.path(gl_metadata_dir, "rbc_filtered_out.csv"),
  col_types = cols("Cell.ID" = "c"))

# Remove the cells from the Seurat object
breast_cancer_patients_filt_cells <- subset(breast_cancer_patients, cells = cells_to_remove$Cell.ID)

# Find cells with extremely low or high number of Features and Counts
cells_to_remove <- WhichCells(breast_cancer_patients_filt_cells, expression = nFeature_RNA < 10 | nCount_RNA > 2500)
# Remove the cells from the Seurat object
breast_cancer_patients_filt_cells <- subset(breast_cancer_patients_filt_cells, cells = cells_to_remove, invert = TRUE)
```

```{r}
#| label: save-filtered-cells-object
#| eval: false

# Save the filtered cells object
saveRDS(breast_cancer_patients_filt_cells, file.path(gl_obj_dir, "breast_cancer_patients_filt_cells.rds"))
```

## Add metadata

```{r}
#| label: patients-groups-metadata-columns

# Name of the cell type metadata column
col_patient_group <- "patient_group"
```

```{r}
#| label: patients-groups
#| eval: false

# Define the groups
patient_groups <- list(
  "ER+" = c(
    "2",
    "4",
    "6"
  ),
  "ER-" = c(
    "1",
    "3",
    "5",
    "7"
  )
)

# Transform the list into a vector
patient_groups_vector <- setNames(rep(names(patient_groups), sapply(patient_groups, length)), unlist(patient_groups))
# Create the cell type group metadata column
# If a cell type does not belong to any cell group, copy over the cell type
breast_cancer_patients_filt_cells@meta.data %<>%
  mutate(
    "{col_patient_group}" := patient_groups_vector[as.character(.data$Patient.ID)]
  )
```

## Data overview

### Cell sizes

```{r}
#| label: cells-size

cell_sizes_info <- list()

# Calculate the cell Width from Heigh and AspectRatio
breast_cancer_patients_filt_cells@meta.data %<>%
  mutate(
    Width := .data$Height * .data$AspectRatio
  )

# For CosMx data, the spatial coordinates are in pixels and the conversion factor can be found in the NanoString documentation:
# https://nanostring-biostats.github.io/CosMx-Analysis-Scratch-Space/posts/flat-file-exports/flat-files-compare.html
cosmx_pixel_to_micron_conversion_factor = 0.12028

# Calculate the width of the cells in micrometers
breast_cancer_patients_filt_cells@meta.data %<>%
  mutate(
    Width_microns := .data$Width * cosmx_pixel_to_micron_conversion_factor
  )
# Calculate the height of the cells in micrometers
breast_cancer_patients_filt_cells@meta.data %<>%
  mutate(
    Height_microns := .data$Height * cosmx_pixel_to_micron_conversion_factor
  )
# Calculate the average diameter of the cells in microns
breast_cancer_patients_filt_cells@meta.data %<>%
  mutate(
    Diameter_microns := (.data$Width_microns + .data$Height_microns) / 2
  )
# Trimean of the diameter of all cells
trimean_diameter_all_cells = trimean(breast_cancer_patients_filt_cells@meta.data$Diameter_microns)
# Mean of the diameter of all cells
mean_diameter_all_cells = mean(breast_cancer_patients_filt_cells@meta.data$Diameter_microns)

# Create table with cell sizes
cells_sizes <- breast_cancer_patients_filt_cells@meta.data %>%
  pivot_longer(
    cols = c(Width_microns, Height_microns), 
    names_to = "Dimension", 
    values_to = "Value") %>%
  dplyr::select(cell_ID, fov, Dimension, Value)

# Plot overlapping histograms with height and width bins
cell_width_height_hist <- ggplot(cells_sizes, aes(x = Value, fill = Dimension)) +
  geom_histogram(position = "identity", binwidth = 1, alpha = 0.5, color = "black", size = 0.2) +
  labs(
    title = "Count of height and width values",
    x = "Length (microns)",
    y = "Count",
    fill = "Dimension"
  )  +
  scale_fill_manual(
    values = c("Height_microns" = "blue", "Width_microns" = "red"),
    labels = c("Height_microns" = "Height", "Width_microns" = "Width")) +
  theme_minimal()
cell_sizes_info[["cell_width_height_hist"]] <- cell_width_height_hist

# Print everything
print(cell_sizes_info)
```

```{r}
#| label: save-cells-size-info
#| eval: false

# Save the filtered cells object
save_data(cell_sizes_info, file.path(gl_img_dir))
```

### Cores table

Create a table with an entry for every FOV in the Seurat object analyzed in this study. The table will contain the patient ID, the serial core, the stamp, and the FOV.

```{r}
#| label: data-overview
#| echo: false

# List of the gene data (1000-plex RNA)
print("List of the genes in the data:")
rownames(breast_cancer_patients)

# Create a data frame to store the table
patient_table <- tibble(
  Patient_ID = character(),
  Serial_Cores = character(),
  Stamps = character(),
  FOVs = character()
)
# Iterate over each patient
for (patient_id in sort(unique(unlist(breast_cancer_patients$Patient.ID)))) {
  # Subset the data for the current patient
  patient_data <- subset(x = breast_cancer_patients@meta.data, subset = Patient.ID == patient_id)

  # Get the unique serial cores for the current patient
  serial_cores <- unique(patient_data$core_serial)

  # Iterate over each serial core
  for (serial_core_id in serial_cores) {
    # Subset the data for the current serial core
    serial_core_data <- subset(x = patient_data, subset = core_serial == serial_core_id)

    # Get the unique stamps for the current serial core
    stamps <- unique(serial_core_data$stamp)
    
    # Iterate over each stamp
    for (stamp_id in stamps) {
      # Subset the data for the current stamp
      stamp_data <- subset(x = serial_core_data, subset = stamp == stamp_id)

      # Get the unique FOVs for the current stamp
      fovs <- unique(stamp_data$fov)

      # Add a row to the patient table for each FOV
      for (fov_id in fovs) {
        patient_table <- patient_table %>% add_row(
          Patient_ID = as.character(patient_id),
          Serial_Cores = as.character(serial_core_id),
          Stamps = as.character(stamp_id),
          FOVs = as.character(fov_id)
        )
      }
    }
  }
}
# Sort the patient_table by Patient_ID, Serial_Cores, and Stamps
patient_table <- patient_table %>%
  arrange(Patient_ID, Serial_Cores, Stamps, desc(FOVs))
# Print the patient table
print(patient_table)

# Print patients info
print("Patients")
patients_ids <- sort(unique(unlist(breast_cancer_patients$Patient.ID)))
print(glue("IDs: {glue_collapse(patients_ids, sep = ', ')}"))
patients_total <- length(patients_ids)
print(glue("Total: {patients_total}"))

# Print cores info
print("Cores")
breast_cancer_cores_names <- sort(unique(breast_cancer_patients@meta.data$core_serial))
print(glue("Names: {glue_collapse(breast_cancer_cores_names, sep = ', ')}"))
breast_cancer_cores_total <- length(breast_cancer_cores_names)
print(glue("Total: {breast_cancer_cores_total}"))

# Print stamps info
print("Stamps")
breast_cancer_stamps_names <- sort(unique(paste(
  breast_cancer_patients@meta.data$core_serial,
  breast_cancer_patients@meta.data$stamp)))
# Replace the space between "M?" and the number with an underscore
breast_cancer_stamps_names <- gsub("([A-Za-z]+)(\\d) (\\d+)", "\\1\\2_\\3", breast_cancer_stamps_names)
print(glue("Names: {glue_collapse(breast_cancer_stamps_names, sep = ', ')}"))
breast_cancer_stamps_total <- length(breast_cancer_stamps_names)
print(glue("Total: {breast_cancer_stamps_total}"))

# Print FOVs info
print("FOVs")
breast_cancer_fovs_nums <- sort(unique(unlist(breast_cancer_patients$fov)))
print(glue("Numbers: {glue_collapse(breast_cancer_fovs_nums, sep = ', ')}"))
breast_cancer_fovs_total <- length(breast_cancer_fovs_nums)
print(glue("Total: {breast_cancer_fovs_total}"))
```

### Tissue micro array

Print the patients' information and create two representation of the TMA: one with the primary diagnosis highlighted and one with the quality of the FOVs with a primary diagnosis of breast cancer highlighted.

```{r}
#| label: TMA-info

# List with plots & dataframe to be saved
TMA_info_to_save <- list()
# List with plots & dataframe to be displayed
TMA_info_to_display <- list()

# Information about the patients involved in the study
patient_info <- read_excel(file.path(gl_metadata_dir, "updatedPACC_Copy of METBRA_patient_v1_now_updated_dec_2022_GOOD_mar_2024_Lanzing.xlsx"))
TMA_info_to_display[["Patient_info"]] <- patient_info

# FOVs & Core serials
LU001FFP03_FOV <- read_excel(file.path(gl_metadata_dir, "LU001FFP03_FOV.xlsx"))
# Core serials, Patients' ID & Primary Diagnosis
TMA_METBRA_COSMX <- read_excel(
  path = file.path(gl_metadata_dir, "TMA_METBRA_COSMX Analysis.xlsx"),
  sheet = "TMA_list")
# FOVs & associated primary diagnosis
FOVs_primary_diagnosis <- left_join(
  x = LU001FFP03_FOV,
  y = TMA_METBRA_COSMX,
  by = c("core_serial" = "Full Serial Number"))
# X, Y & Z FOVs positions
tissue_micro_array <- read_csv(gzfile(
  file.path(gl_root_dir, "Analysis", "flat_files", "LU001FFP03", "LU001FFP03_fov_positions_file.csv.gz")),
  col_types = cols(
  Slide = col_integer(),
  X_mm = col_double(),
  Y_mm = col_double(),
  Z_mm = col_double(),
  ZOffset_mm = col_double(),
  ROI = col_integer(),
  FOV = col_integer(),
  Order = col_integer(),
  Run_Tissue_name = col_character()))
# FOVs, associated primary diagnosis & X, Y, Z positions
FOVs_prim_diag_pos <- left_join(
  x = tissue_micro_array,
  y = FOVs_primary_diagnosis,
  by = c("FOV" = "fov"))
# FOVs, associated primary diagnosis, X, Y positions & quality
FOVs_prim_diag_pos_qual <- FOVs_prim_diag_pos %>%
  dplyr::mutate(Quality = case_when(
    is.na(`Primary Diagnosis`) ~ NA_character_,
    `Primary Diagnosis` != "breast cancer" ~ NA_character_,
    FOV %in% breast_cancer_fovs_nums ~ "good",
    TRUE ~ "bad"
  ))

# Plots shared parameters
square_size <- 5
square_text_size <- 1.6
title <- "TMA LU001FFP03"

# TMA plot with FOVs positions and associated primary diagnosis
LU001FFP03_TMA_primary_diag <- ggplot(FOVs_prim_diag_pos_qual, aes(x = X_mm, y = Y_mm)) +
  geom_point(aes(color = `Primary Diagnosis`), shape = 15, size = square_size) +
  geom_text(aes(label = FOV), size = square_text_size) +
  coord_equal() +
  labs(title = title,
       color = "Primary diagnosis") +
  scale_color_manual(values = c("breast cancer" = "#00B5EE", "lung cancer" = "#E26EF7"),
                     na.translate = TRUE, 
                     na.value = "grey50",
                     breaks = c("breast cancer", "lung cancer"))
LU001FFP03_TMA_primary_diag_name <- paste0("TMA_LU001FFP03_primary_diagnosis_highlighted")
TMA_info_to_save[[LU001FFP03_TMA_primary_diag_name]] <- LU001FFP03_TMA_primary_diag

# TMA plot with FOVs positions and quality of those with primary diagnosis of breast cancer
LU001FFP03_TMA_breast_cancers_stamps_quality <- ggplot(
  FOVs_prim_diag_pos_qual, aes(x = X_mm, y = Y_mm)) +
  geom_point(aes(color = `Quality`), shape = 15, size = square_size) +
  geom_text(aes(label = FOV), size = square_text_size) +
  coord_equal() +
  labs(title = title,
       color = "Breast cancer\nstamps quality") +
  scale_color_manual(values = c("good" = "#00BB44", "bad" = "#F8766D"),
                     na.translate = TRUE, 
                     na.value = "grey50",
                     breaks = c("good", "bad"))
LU001FFP03_TMA_breast_cancer_stamps_highlighted_name <- 
  paste0("TMA_LU001FFP03_breast_cancer_stamps_quality")
TMA_info_to_save[[LU001FFP03_TMA_breast_cancer_stamps_highlighted_name]] <- 
  LU001FFP03_TMA_breast_cancers_stamps_quality

print(c(TMA_info_to_display, TMA_info_to_save))
```

```{r}
#| label: save-plots-TMA-info
#| include: false
#| echo: false
#| eval: false

save_data(TMA_info_to_save, file.path(gl_img_dir, "TMA"))
```

## Quality assurance

```{r}
#| label: qa

# Check if there are mitochondrial genes
mt_gene_count <- sum(grepl("^MT-", rownames(breast_cancer_patients_filt_cells[["RNA"]])))
if (mt_gene_count > 0) {
  cat("TRUE. Number of mitochondrial genes:", mt_gene_count)
} else {
  cat("FALSE. No mitochondrial genes found.")
}
```

## Cell typing

The clustering performed by Insitutype  uses the raw counts, therefore it is useless to use the integrated data because Seurat does not provide an adjusted count matrix.

```{r}
#| label: ins-metadata-columns

# Name of the column with the raw insitutype clusters
col_ist_raw <- "patients_ist_semisup_clusters"
# Name of the metadata column with the annotated insitutype clusters
col_ist_ann <- "patients_ist_semisup_clusters_ann"

# Folder where to save the Insitutype plots
dir_ist_plots <- file.path(gl_img_dir, "Insitutype")
```

### Insitutype Clustering

```{r}
#| label: insitutype-load

# Read the Insitutype data from the drive
breast_cancer_patients_analyze <- readRDS(file.path(gl_obj_dir, "breast_cancer_patients_analyze.rds"))
patients_ist_semisup <- readRDS(file.path(gl_obj_dir, "patients_ist_semisup.rds"))
```

```{r}
#| label: insitutype-per-patient
#| eval: false

# Create a new Seurat object identical to filt cells
breast_cancer_patients_analyze <- breast_cancer_patients_filt_cells
# Arrays to split
assays_to_split <- c("RNA", "NegativeProbes", "SystemControl")
# Split the arrays
for (assay in assays_to_split) {
  breast_cancer_patients_analyze[[assay]] <- split(
    breast_cancer_patients_analyze[[assay]],
    f = breast_cancer_patients_analyze$Patient.ID)
}
# Set Patient.ID as the identity
Idents(breast_cancer_patients_analyze) <- "Patient.ID"

# Create a list to store the results of the insitutype clustering per patient
patients_ist_semisup <- list()
# Create a list to store the results of the cluster num search function
patients_clusters_num_search_info <- list()
# Set the reference profile
reference_profile <- io_brain_profiles_matrix
# Insitutype clustering - Loop over every patient
for (patient_id in unique(breast_cancer_patients_analyze$Patient.ID)) {

  # Print the patient ID
  print(glue("Analysis of patient {patient_id}"))
  # Compose string of count layer patient
  count_layer_patient <- paste0("counts.", patient_id)
  # Extract the count data for the selected patient
  patient_rna_counts <- LayerData(
    breast_cancer_patients_analyze,
    assay = "RNA",
    layer = count_layer_patient) %>%
  as.matrix() %>%
  t()
  
  # Extract the negative probes for the selected patient
  patient_avg_neg_probes <- LayerData(
    breast_cancer_patients_analyze,
    assay = "NegativeProbes",
    layer = count_layer_patient) %>%
  as.matrix() %>%
  t() %>%
  Matrix::rowMeans()
  
  # Features to be used for the cohorting
  features <- c("Mean.PanCK", "Mean.CD45", "Mean.CD68")
  patient_immunofluorescence <- FetchData(
  object = breast_cancer_patients_analyze, 
  vars = features, # Specify which metadata columns to extract
  cells = WhichCells(breast_cancer_patients_analyze, idents = patient_id)
  )
  
  # Cohort of the patient
  # fastCohorting is stochastic, so set the seed for reproducibility
  set.seed(42);
  # "Gaussian_transform = TRUE" maps variables to gaussians in order to place dramatically different variables on the same scale
  patient_cohort <- fastCohorting(
    patient_immunofluorescence,
    gaussian_transform = TRUE)
  # check clusters and cohort numbers
  table(patient_cohort)
  
  # Set the range to search for the optimal number of extra clusters
  clusts_search_space = 1:8
  set.seed(6)
  # Search the optimal numer of extra clusters
  clusters_num_search_info <- chooseClusterNumber(
    counts = patient_rna_counts,
    neg = patient_avg_neg_probes,
    fixed_profiles = reference_profile,
    n_clusts = clusts_search_space)
  # Save the result to a list
  patients_clusters_num_search_info[[patient_id]] <- clusters_num_search_info
  
  # Get the best number of clusters
  clusts_num <- clusters_num_search_info$best_clust_number
  # Print the best number of clusters
  print(glue("Best number of clusters: {clusts_num}"))
  
  # Semi-supervised learning with insitutype and reference profiles
  # Insitutype needs integers, if given floating point numbers it fails with misleading errors
  patients_ist_semisup[[patient_id]] <- insitutype(
    x = patient_rna_counts,
    neg = patient_avg_neg_probes,
    cohort = patient_cohort,
    
    # Enter your own per-cell background estimates here if you
    # have them; otherwise insitutype will use the negprobes to
    # estimate background for you.
    bg = NULL,
    # Group the cells the do not correspond to any type in the reference matrix
    n_clusts = 1,
    reference_profiles = reference_profile,
    # Update the reference profile based on the current data
    update_reference_profiles = FALSE,
    # choosing inadvisably low numbers to speed the vignette; using the defaults
    # in recommended.
    # This is the number of cells used in each phase, because of random sampling
    n_phase1 = 200,
    n_phase2 = 500,
    n_phase3 = 1000,
    n_starts = 6,
    max_iters = 12
  )
}

# Join Layers
for (assay in assays_to_split) {
  breast_cancer_patients_analyze <- JoinLayers(breast_cancer_patients_analyze, assay = assay, layers = "counts")
}

# Merge patient insitutype clusters
merged_ist_results <- c()
for (i in 1:length(patients_ist_semisup)) {
  merged_ist_results <- c(merged_ist_results, patients_ist_semisup[[i]]$clust)
}
# Add the raw insitutype clusters to the Seurat object
breast_cancer_patients_analyze <- AddMetaData(
  object = breast_cancer_patients_analyze,
  metadata = merged_ist_results,
  col.name = col_ist_raw)

# Rename unknown clusters to tumor
breast_cancer_patients_analyze@meta.data %<>%
  mutate(
    "{col_ist_ann}" := case_match(
      .data[[col_ist_raw]],
      # Rename the cluster of cells that do not correspond to any profile
      c("a") ~ "Other",
      # Merge cell profiles that are not widely recognized by the literature
      c("Astrocyte A", "Astrocyte B") ~ "Astrocyte",
      c("Inhibitory neuron A", "Inhibitory neuron B", "Inhibitory neuron C") ~ "Inhibitory neuron",
      c("Microglia A", "Microglia B") ~ "Microglia",
      c("Endothelial IO", "Endothelial Brain") ~ "Endothelial",
      .default = .data[[col_ist_raw]]
    )
  )
```

### Add cell groups

```{r}
#| label: cell-groups-metadata-columns

# Name of the cell type metadata column
col_cell_group <- "cell_group"
```

```{r}
#| label: cells-groups
#| eval: false

# Define the groups
cell_groups <- list(
  "Myeloids" = c(
    "Macrophage",
    "Mast cell",
    "Monocyte",
    "Neutrophil",
    "Dendritic cell",
    "Plasmacytoid dendritic cell"
  ),
  "Stromal cells" = c(
    "Endothelial",
    "Fibroblast"
  ),
  "Lymphocytes" = c(
    "B cell",
    "T cell CD4",
    "T cell CD8",
    "T cell regulatory",
    "NK cell",
    "Plasma",
    "Plasmablast"
  ),
  "Brain cells" = c(
    "Inhibitory neuron",
    "Inhibitory neuron A",
    "Inhibitory neuron B",
    "Inhibitory neuron C",
    # Excitatory neurons
    "L2/3 neuron",
    "L4 neuron",
    "L6 neuron",
    # Glial cells
    "Oligodendrocyte-like",
    "Oligodendrocyte precursor cell",
    "Oligodendrocyte",
    # Microglia cells
    "Microglia",
    "Microglia A",
    "Microglia B",
    # Astrocyte cells
    "Astrocyte",
    "Astrocyte A",
    "Astrocyte B"
  )
)

# Transform the list into a vector
cell_groups_vector <- setNames(rep(names(cell_groups), sapply(cell_groups, length)), unlist(cell_groups))
# Create the cell type group metadata column
# If a cell type does not belong to any cell group, copy over the cell type
breast_cancer_patients_analyze@meta.data %<>%
  mutate(
    "{col_cell_group}" := ifelse(
      is.na(cell_groups_vector[.data[[col_ist_ann]]]),
      .data[[col_ist_ann]],
      cell_groups_vector[.data[[col_ist_ann]]]
    )
  )
```

### Info

```{r}
#| label: insitutype-info

ist_info <- list()

# CELL TYPES
# Create a tibble with cell count and percentage of every cluster
ist_summary_cell_types_count <- breast_cancer_patients_analyze@meta.data %>%
  count(.data[[col_ist_ann]], name = "cell_count") %>%
  mutate(percentage = round((cell_count / sum(cell_count)) * 100, 3)) %>%
  dplyr::rename(cell_type = .data[[col_ist_ann]]) %>%
  as_tibble()
ist_info[["ist_summary_cell_types_count"]] <- ist_summary_cell_types_count

# Create a table with the cell count and percentage divided by patient
ist_summary_cell_types_count_per_patient <- breast_cancer_patients_analyze@meta.data %>%
  count(!!sym(col_ist_ann), Patient.ID) %>%
  group_by(Patient.ID) %>%
  mutate(percentage = round(n / sum(n) * 100, 4)) %>%
  arrange(Patient.ID, !!sym(col_ist_ann)) %>%
  dplyr::rename(cell_type = !!sym(col_ist_ann)) %>%
  as_tibble()
ist_info[["ist_summary_cell_types_count_per_patient"]] <- ist_summary_cell_types_count_per_patient

# CELL GROUPS
# Create a tibble with cell count and percentage of every group
ist_summary_cell_groups_count <- breast_cancer_patients_analyze@meta.data %>%
  count(.data[[col_cell_group]], name = "cell_count") %>%
  mutate(percentage = round((cell_count / sum(cell_count)) * 100, 3)) %>%
  dplyr::rename(cell_group = .data[[col_cell_group]]) %>%
  as_tibble()
ist_info[["ist_summary_cell_groups_count"]] <- ist_summary_cell_groups_count

# Create a table with the cell count and percentage divided by patient
ist_summary_cell_groups_count_per_patient <- breast_cancer_patients_analyze@meta.data %>%
  count(!!sym(col_cell_group), Patient.ID) %>%
  group_by(Patient.ID) %>%
  mutate(percentage = round(n / sum(n) * 100, 4)) %>%
  arrange(Patient.ID, !!sym(col_cell_group)) %>%
  dplyr::rename(cell_group = !!sym(col_cell_group)) %>%
  as_tibble()
ist_info[["ist_summary_cell_groups_count_per_patient"]] <- ist_summary_cell_groups_count_per_patient

for (table in ist_info) {
  print(datatable(table))
}
```

```{r}
#| echo: false

# Save the Insitutype plots
save_data(ist_info, dir_ist_plots)
```

### SCTransform

```{r}
#| label: rna-sctransform-calculate
#| eval: false

## SCTransform
# Normalize and scale
breast_cancer_patients_analyze <- SCTransform(
  breast_cancer_patients_analyze,
  do.correct.umi = TRUE,
  return.only.var.genes = FALSE,
  ncells = 6000,
  assay = "RNA",
  new.assay.name = "SCT",
  seed.use = 13,
  verbose = TRUE)
# Run PCA
breast_cancer_patients_analyze <- RunPCA(
  breast_cancer_patients_analyze,
  assay = "SCT",
  reduction.key = "SCTPC_",
  reduction.name = "sct_pca_patients",
  seed.use = 42,
  verbose = TRUE)
# Elbow plot
patients_sct_elbow_plot <- generate_variance_elbow_plots(breast_cancer_patients_analyze, "sct_pca_patients", 50)
print(patients_sct_elbow_plot)
# Run UMAP
breast_cancer_patients_analyze <- RunUMAP(
  breast_cancer_patients_analyze,
  reduction = "sct_pca_patients",
  dims = 1:22,
  reduction.key = "SCTUMAP_",
  reduction.name = "sct_umap_patients",
  seed.use = 42)
```

```{r}
#| label: rna-sctransform-plot

# List to print and save
patients_ist_sct <- list()

# Plot cells by type
patients_ist_type_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_ist_ann,
  reduction = "sct_umap_patients",
  cols = palette_cell_types) +
  labs(title = "All cell types") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      ncol=1,
      keywidth = unit(0.5, "lines"),
      keyheight = unit(0.8, "lines"),
      spacing = unit(0.2, "lines"))
  )  +
  theme(
    legend.text = element_text(size = 8),
  ) &
  NoAxes()
patients_ist_sct[["patients_ist_type_sct_plot"]] <- patients_ist_type_sct_plot

# Plot cells by group
patients_ist_group_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_cell_group,
  reduction = "sct_umap_patients",
  cols = palette_cell_types) +
  labs(title = "All cell groups") &
  NoAxes()
patients_ist_sct[["patients_ist_group_sct_plot"]] <- patients_ist_group_sct_plot

# Plot patients
patients_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = "Patient.ID",
  reduction = "sct_umap_patients",
  cols = palette_patients) +
  labs(title = "All cells") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      title = "Patient"
    )
  ) &
  NoAxes()
patients_ist_sct[["patients_sct_plot"]] <- patients_sct_plot

# Plot estrogen receptors
estrogen_receptor_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_patient_group,
  reduction = "sct_umap_patients",
  cols = palette_tumor_types) +
  labs(title = "All cells") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      title = "Patient"
    )
  ) &
  NoAxes()
patients_ist_sct[["estrogen_receptor_sct_plot"]] <- estrogen_receptor_sct_plot

Idents(breast_cancer_patients_analyze) <- "neutral"
# Check the quantity and the expression level of genes after normalization
vln_plot_feat_count_sct <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "SCT",
  layer = "data",
  features = c("nFeature_SCT", "nCount_SCT"),
  ncol = 2,
  pt.size = 0
)
# Customize the titles for each plot
vln_plot_feat_count_sct[[1]] <- vln_plot_feat_count_sct[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_sct[[2]] <- vln_plot_feat_count_sct[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_sct <- vln_plot_feat_count_sct + plot_annotation(title = "After SCT normalization")
# Save the plot
patients_ist_sct[["Violin_plot_features_count_sct"]] <- vln_plot_feat_count_sct

# Check the quantity and the expression level of genes per patient after normalization
vln_plot_feat_count_patients_sct <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "SCT",
  layer = "data",
  features = c("nFeature_SCT","nCount_SCT"),
  ncol = 2,
  pt.size = 0,
  group.by = "Patient.ID",
  cols = palette_patients
)
# Customize the titles for each plot
vln_plot_feat_count_patients_sct[[1]] <- vln_plot_feat_count_patients_sct[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_patients_sct[[2]] <- vln_plot_feat_count_patients_sct[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_patients_sct <- vln_plot_feat_count_patients_sct + plot_annotation(title = "After SCT normalization")
# Save the plot
patients_ist_sct[["Violin_plot_patients_features_count_sct"]] <- vln_plot_feat_count_patients_sct

# QC the normalization
feature_plot_feat_count_sct <- FeaturePlot(
  breast_cancer_patients_analyze,
  features = c("nFeature_RNA", "nCount_RNA"),
  reduction = "sct_umap_patients",
  combine = TRUE) + 
  plot_annotation(title = "After SCT normalization")
# Save the plot
patients_ist_sct[["Feature_plot_features_count_sct"]] <- feature_plot_feat_count_sct

# Print
print(patients_ist_sct)
```

### Standard normalization

```{r}
#| label: rna-standard-normalization-calculate
#| eval: false

# Default assay & layer
DefaultAssay(breast_cancer_patients_analyze) <- "RNA"
DefaultLayer(breast_cancer_patients_analyze[["RNA"]]) <- "counts"

# Normalize
breast_cancer_patients_analyze <- NormalizeData(
  breast_cancer_patients_analyze,
  assay = "RNA")
# Scale
breast_cancer_patients_analyze <- ScaleData(
  breast_cancer_patients_analyze,
  assay = "RNA")
# Find variable features
breast_cancer_patients_analyze <- FindVariableFeatures(
  breast_cancer_patients_analyze,
  selection.method = "vst",
  nfeatures = 1000,
  assay = "RNA")
# RunPCA
breast_cancer_patients_analyze <- RunPCA(
  breast_cancer_patients_analyze,
  assay = "RNA",
  reduction.key = "RNAPC_",
  reduction.name = "rna_pca_patients",
  seed.use = 42,
  verbose = TRUE)
# Elbow plot
patients_rna_elbow_plot <- generate_variance_elbow_plots(breast_cancer_patients_analyze, "rna_pca_patients", 50)
print(patients_rna_elbow_plot)
# Run UMAP
breast_cancer_patients_analyze <- RunUMAP(
  breast_cancer_patients_analyze,
  reduction = "rna_pca_patients",
  dims = 1:22,
  reduction.key = "RNAUMAP_",
  reduction.name = "rna_umap_patients",
  seed.use = 42)
```

```{r}
#| label: rna-standard-normalization-plot

# List to print and save
patients_ist_rna <- list()

# Plot cells
patients_ist_type_rna_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = "patients_ist_semisup_clusters_ann",
  reduction = "rna_umap_patients",
  cols = palette_cell_types)
patients_ist_rna[["patients_ist_type_rna_plot"]] <- patients_ist_type_rna_plot
# Plot patients
patients_rna_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = "Patient.ID",
  reduction = "rna_umap_patients",
  cols = palette_patients)
patients_ist_rna[["patients_rna_plot"]] <- patients_rna_plot

Idents(breast_cancer_patients_analyze) <- "neutral"
# Check the quantity and the expression level of genes after normalization
vln_plot_feat_count_rna <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "RNA",
  layer = "data",
  features = c("nFeature_RNA", "nCount_RNA"),
  ncol = 2,
  pt.size = 0
)
# Customize the titles for each plot
vln_plot_feat_count_rna[[1]] <- vln_plot_feat_count_rna[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_rna[[2]] <- vln_plot_feat_count_rna[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_rna <- vln_plot_feat_count_rna + plot_annotation(title = "After RNA normalization")
# Save the plot
patients_ist_rna[["Violin_plot_features_count_rna"]] <- vln_plot_feat_count_rna

# Check the quantity and the expression level of genes per patient after normalization
vln_plot_feat_count_patients_rna <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "RNA",
  layer = "data",
  features = c("nFeature_RNA","nCount_RNA"),
  ncol = 2,
  pt.size = 0,
  group.by = "Patient.ID",
  cols = palette_patients
)
# Customize the titles for each plot
vln_plot_feat_count_patients_rna[[1]] <- vln_plot_feat_count_patients_rna[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_patients_rna[[2]] <- vln_plot_feat_count_patients_rna[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_patients_rna <- vln_plot_feat_count_patients_rna + plot_annotation(title = "After RNA normalization")
# Save the plot
patients_ist_rna[["Violin_plot_patients_features_count_rna"]] <- vln_plot_feat_count_patients_rna

# QC the normalization
feature_plot_feat_count_rna <- FeaturePlot(
  breast_cancer_patients_analyze,
  features = c("nFeature_RNA", "nCount_RNA"),
  reduction = "rna_umap_patients",
  combine = TRUE) + 
  plot_annotation(title = "After RNA normalization")
# Save the plot
patients_ist_rna[["Feature_plot_features_count_rna"]] <- feature_plot_feat_count_rna

# Print
print(patients_ist_rna)
```

### Plot

```{r}
#| label: insitutype-plot

# Save insitutype data
insitutype_data <- list()

# Generate summary statistics for the Insitutype clusters
insitutype_data[["insitutype_clust_summary_patients"]] <- create_cluster_summary_per_patient(breast_cancer_patients_analyze, col_ist_ann)

# Violin plot with the expression of panCK, CD45 and CD68 for each Insitutype clusters
ist_clust_expr <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "RNA",
  layer = "data",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  pt.size = 0,
  group.by = col_ist_ann,
  combine = FALSE,
  cols = palette_cell_types
)
ist_clust_expr <- lapply(ist_clust_expr, function(x) x &NoLegend())
insitutype_data <- c(insitutype_data, ist_clust_expr)

# Calculate the mean of CD45, CD68 and PanCK for each Insitutype cluster
ist_ann_cluster_statistics <- breast_cancer_patients_analyze@meta.data %>%
  group_by(!!sym(col_ist_ann)) %>%
  summarise(
    `Mean PanCK` = mean(Mean.PanCK),
    `Mean CD45` = mean(Mean.CD45),
    `Mean CD68` = mean(Mean.CD68),
    .groups = "drop"
  )
insitutype_data[["ist_ann_cluster_statistics"]] <- ist_ann_cluster_statistics

print(insitutype_data)
```

```{r}
#| label: insitutype-save-data
#| eval: false

# Save the Insitutype plots
save_data(patients_ist_sct, dir_ist_plots)
save_data(patients_ist_rna, dir_ist_plots)
save_data(insitutype_data, dir_ist_plots)
```

```{r}
#| label: insitutype-save-rds
#| eval: false

# Save insitutype list
saveRDS(patients_ist_semisup, file.path(gl_obj_dir, "patients_ist_semisup.rds"))
# Save Seurat object
saveRDS(breast_cancer_patients_analyze, file.path(gl_obj_dir, "breast_cancer_patients_analyze.rds"))
```

## Split

Create two separate Seurat objects for tumor and normal cells using the Insitutype clusters

```{r}
#| label: add-metadata-to-filt-cells
#| eval: false

# Add insitutype annotated clusters to filt cells object
breast_cancer_patients_filt_cells <- AddMetaData(
  object = breast_cancer_patients_filt_cells,
  metadata = FetchData(
    object = breast_cancer_patients_analyze,
    vars = col_ist_ann),
  col.name = col_ist_ann
)
# Add insitutype group clusters to filt cells object
breast_cancer_patients_filt_cells <- AddMetaData(
  object = breast_cancer_patients_filt_cells,
  metadata = FetchData(
    object = breast_cancer_patients_analyze,
    vars = col_cell_group),
  col.name = col_cell_group
)
```

```{r}
#| label: save-filt-cells-obj-with-metadata
#| eval: false

# Save the Seurat object filt cells with the Insitutype clusters
saveRDS(breast_cancer_patients_filt_cells, file.path(gl_obj_dir, "breast_cancer_patients_filt_cells.rds"))
```

```{r}
#| label: read-insitutype-annotation-col

# Extract the Insitutype clusters metadata column
ist_ann_column <- FetchData(
  object = breast_cancer_patients_filt_cells,
  vars = col_ist_ann)
```

```{r}
#| label: insitutype-split
#| eval: false

# Create Seurat objects with the non-cancerous cells
breast_cancer_patients_normal_cells <- 
  breast_cancer_patients_filt_cells[, which(x = ist_ann_column != "Other")]
# Create Seurat objects with the cancerous cells
breast_cancer_patients_other_cells <-
  breast_cancer_patients_filt_cells[, which(x = ist_ann_column == "Other")]
```

## Normal cells

### Compute

```{r}
#| label: normal-cells-load

# Load normal cells object from memory
breast_cancer_patients_normal_cells <- readRDS(file.path(gl_obj_dir, "breast_cancer_patients_normal_cells.rds"))
```

```{r}
#| label: normal-cells-computation
#| eval: false

# Run SCTransform
breast_cancer_patients_normal_cells <- SCTransform(
  breast_cancer_patients_normal_cells,
  do.correct.umi = TRUE,
  return.only.var.genes = FALSE,
  assay = "RNA",
  new.assay.name = "SCT",
  seed.use = 13,
  verbose = TRUE)
# Run PCA
breast_cancer_patients_normal_cells <- RunPCA(
  breast_cancer_patients_normal_cells,
  assay = "SCT",
  reduction.key = "SCTPC_",
  reduction.name = "sct_pca_normal_cells",
  seed.use = 42,
  verbose = TRUE)
# Generate variance elbow plots
generate_variance_elbow_plots(breast_cancer_patients_normal_cells, "sct_pca_normal_cells", 50)
# Run UMAP
breast_cancer_patients_normal_cells <- RunUMAP(
  breast_cancer_patients_normal_cells,
  reduction = "sct_pca_normal_cells",
  dims = 1:30,
  reduction.key = "SCTUMAP_",
  reduction.name = "sct_umap_normal_cells",
  seed.use = 42)
```

### Plot

```{r}
#| label: normal-cells-plot

# Create empty list to store normal cells images
normal_cells_images <- list()

# Calculate the statistics for the normal cells
normal_cells_cluster_statistics <- breast_cancer_patients_normal_cells@meta.data %>%
  # Group by patient and cluster, then calculate percentage
  group_by(Patient.ID, !!sym(col_ist_ann), !!sym(col_cell_group)) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Patient.ID) %>%
  mutate(Percentage = count / sum(count) * 100) %>%
  ungroup() %>%
  # Ensure Patient.ID is a factor
  mutate(Patient.ID = as.factor(Patient.ID)) %>%
  # Calculate mean and sd for each cluster
  group_by(!!sym(col_ist_ann)) %>%
  mutate(
    MeanPercentage = mean(Percentage),
    SDPercentage = sd(Percentage)
  ) %>%
  ungroup()
normal_cells_images[["normal_cells_cluster_statistics"]] <- normal_cells_cluster_statistics

# Plot the percentages of the various types of cells (except cancer cells)
normal_cells_cluster_distribution_barplot <- normal_cells_cluster_statistics %>%
  # Plot the data in a grouped barplot
  ggplot(aes(x = !!sym(col_ist_ann), y = Percentage, fill = Patient.ID)) +
  geom_bar(stat = "identity", position = position_dodge2(preserve = "single", padding = 0), width = .8) +
  facet_grid(cols = ggplot2::vars(!!sym(col_cell_group)), scales = "free_x", space = "free") +
  theme_minimal() +
  labs(x = NULL, 
       y = "Percentage of Cells", 
       title = "Normal Cells Types Distribution by Patient",
       fill = "Patient") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.spacing = unit(0.8, "lines")) +
  scale_fill_manual(values = palette_patients)
normal_cells_images[["normal_cells_cluster_distribution_barplot"]] <- normal_cells_cluster_distribution_barplot

# Plot the distribution of normal cell clusters by patient
normal_cells_cluster_distribution_dotplot <- normal_cells_cluster_statistics %>%
  # Plot the data
  ggplot(aes(x = Percentage, y = !!sym(col_ist_ann))) +
  # Add dots for each patient
  geom_point(aes(color = Patient.ID), size = 3, alpha = 0.7) +
  # Add mean percentage point
  stat_summary(aes(shape = "Mean"), fun = mean, geom = "point", size = 5, color = "black", alpha = 0.7) +
  # Add standard deviation error bars
  geom_errorbarh(aes(xmin = MeanPercentage - SDPercentage, 
                     xmax = MeanPercentage + SDPercentage, 
                     y = !!sym(col_ist_ann),
                     linetype = "Standard Deviation"), 
                 color = "black", alpha = 0.7, height = 0.5, linewidth = 0.2) +
  theme_minimal() +
  ggforce::facet_col(
    facets = col_cell_group,
    scales = "free_y",
    space = "free",
    drop = TRUE,
    strip.position = "top"
  ) +
  labs(x = "Percentage of Cells", y = NULL,
       title = "Normal Cells Types Distribution by Patient",
       color = "Patient") +
  scale_color_manual(values = palette_patients) +
  scale_shape_manual(values = c("Mean" = 18), labels = c("Mean")) +
  scale_linetype_manual(values = c("Standard Deviation" = "solid"), labels = c("Standard Deviation")) +
  guides(
    color = guide_legend(order = 1),
    shape = guide_legend(order = 2, title = "Statistics"),
    linetype = guide_legend(order = 3, title = "Statistics")
  )
normal_cells_images[["normal_cells_cluster_distribution_dotplot"]] <- normal_cells_cluster_distribution_dotplot

# Umap normal cells patients
normal_cells_patients_umap_plot <- DimPlot(
  object = breast_cancer_patients_normal_cells,
  group.by = "Patient.ID",
  reduction = "sct_umap_normal_cells",
  cols = palette_patients
  )  +
  labs(title = "Non-malignant cells") +
  guides(
    color = guide_legend(
      title = "Patient",
      override.aes = list(size=2)
    )
  ) &
  NoAxes()
normal_cells_images[["normal_cells_patients_umap_plot"]] <- normal_cells_patients_umap_plot

# Umap normal cells types
normal_cells_type_umap_plot <- DimPlot(
  object = breast_cancer_patients_normal_cells,
  group.by = col_ist_ann,
  reduction = "sct_umap_normal_cells",
  cols = palette_cell_types
  )  +
  labs(title = "Non-malignant cell types") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      ncol=1,
      keywidth = unit(0.5, "lines"),
      keyheight = unit(0.8, "lines"),
      spacing = unit(0.2, "lines"))
  ) +
  theme(
    legend.text = element_text(size = 8),
  ) &
  NoAxes()
normal_cells_images[["normal_cells_type_umap_plot"]] <- normal_cells_type_umap_plot

# Umap normal cells groups
normal_cells_group_umap_plot <- DimPlot(
  object = breast_cancer_patients_normal_cells,
  group.by = col_cell_group,
  reduction = "sct_umap_normal_cells",
  cols = palette_cell_types
  )  +
  labs(title = "Non-malignant cell groups") &
  NoAxes()
normal_cells_images[["normal_cells_group_umap_plot"]] <- normal_cells_group_umap_plot

print(normal_cells_images)
```

```{r}
#| label: normal-cells-save-plots
#| eval: false

# Save the normal cells plots
save_data(normal_cells_images, file.path(gl_img_dir, "Normal cells"))
```

```{r}
#| label: normal-cells-save-rds
#| eval: false

# Save the Seurat object
saveRDS(breast_cancer_patients_normal_cells, file.path(gl_obj_dir, "breast_cancer_patients_normal_cells.rds"))
```

## Macrophages

```{r}
#| label: macrophage-cells-load

# Load macrophage cells object from memory
breast_cancer_patients_macrophage_cells <- readRDS(file.path(gl_obj_dir, "breast_cancer_patients_macrophage_cells.rds"))
```

```{r}
#| label: macrophage-cells-compute
#| eval: false

breast_cancer_patients_macrophage_cells <- 
  breast_cancer_patients_filt_cells[, which(x = ist_ann_column == "Macrophage")]
```

### Cluster

```{r}
#| label: macrophage-cells-metadata-columns

# Name of the metadata column with the other clusters
col_macrophage_cells_clust_res_prefix <- "macrophage_cells_clusters_res_"
# Find clusters of macrophage cells
# The default resolution is 1, increase it to get more clusters or decrease it to get fewer clusters
# Try a range of resolutions
macrophage_cells_seq_res <- seq(0.4, 1.0, by = 0.2)
# Create custom cluster names based on the actual resolution values
macrophage_cells_cluster_seq_res <-
  glue::glue("{col_macrophage_cells_clust_res_prefix}{macrophage_cells_seq_res}")
```

```{r}
#| label: macrophage-cells-compute
#| eval: false

# After subsetting a Seurat object it is good to normalize it again
breast_cancer_patients_macrophage_cells <- SCTransform(
  breast_cancer_patients_macrophage_cells,
  return.only.var.genes = FALSE,
  assay = "RNA",
  new.assay.name = "SCT",
  verbose = TRUE)

# Run PCA
breast_cancer_patients_macrophage_cells <- RunPCA(
  breast_cancer_patients_macrophage_cells,
  reduction.key = "PC_",
  reduction.name = "pca",
  seed.use = 33,
  verbose = TRUE)
# Generate variance elbow plots
generate_variance_elbow_plots(breast_cancer_patients_macrophage_cells, "pca", 50)
# Dimension to use for subsequent analysis, decided lokking at the elbow plot
macrophage_cells_dims <- 1:29
# Find neighbors of other cells
# Number of PCA dimensions used in Seurat's FindNeighbors function
#
# Using MORE dimensions:
# Captures more subtle biological variation
# Includes more complex relationships between genes
# May include more noise/technical artifacts
# Computationally more intensive
#
# Using FEWER dimensions:
# Focuses on major sources of variation
# More robust to technical noise
# May miss subtle biological signals
# Computationally faster
breast_cancer_patients_macrophage_cells <- FindNeighbors(
  breast_cancer_patients_macrophage_cells,
  reduction = "pca",
  dims = macrophage_cells_dims,
  verbose = TRUE)

# Find clusters at different resolutions
breast_cancer_patients_macrophage_cells <- FindClusters(
  breast_cancer_patients_macrophage_cells,
  resolution = macrophage_cells_seq_res,
  cluster.name = macrophage_cells_cluster_seq_res,
  random.seed = 5,
  verbose = TRUE)

# Run UMAP
breast_cancer_patients_macrophage_cells <- RunUMAP(
  breast_cancer_patients_macrophage_cells,
  reduction = "pca",
  reduction.key = "UMAP_",
  reduction.name = "umap",
  dims = macrophage_cells_dims,
  verbose = TRUE,
  seed.use = 42)
```

### Plot

```{r}
#| label: macrophage-cells-plot

macrophage_cells_plots_to_save <- list()

# View UMAP with other cells at different clustering resolutions
macrophage_cells_different_resolutions <- DimPlot(
  breast_cancer_patients_macrophage_cells,
  reduction = "umap",
  ncol = 2,
  group.by = macrophage_cells_cluster_seq_res,
  label = TRUE,
  ) & 
  NoLegend() & 
  NoAxes() & 
  theme(
  plot.margin = unit(c(0, 0, 0, 0), "lines"),
  plot.title = element_text(size = 12, face = "bold")
  )
macrophage_cells_plots_to_save[["macrophage_cells_different_resolutions"]] <- macrophage_cells_different_resolutions

# View how resolution affects the number of clusters
macrophage_cells_clustree <- clustree(
  breast_cancer_patients_macrophage_cells@meta.data,
  prefix = col_macrophage_cells_clust_res_prefix)
macrophage_cells_plots_to_save[["macrophage_cells_clustree"]] <- macrophage_cells_clustree

# View UMAP with macrophages and patient clusters
macrophage_cells_patient_id_plot <- DimPlot(
  breast_cancer_patients_macrophage_cells,
  reduction = "umap",
  label = TRUE,
  label.box = TRUE,
  group.by = "Patient.ID",
  cols = palette_patients) +
  labs(title = "Patient ID clusters") &
  NoLegend() &
  NoAxes()
macrophage_cells_plots_to_save[["macrophage_cells_patient_id_plot"]] <- macrophage_cells_patient_id_plot

# Chosen resolution
chosen_macrophage_cells_cluster_resolution <- 1
# Chosen cluster
col_macrophage_cells_chosen_cluster <- glue::glue("{col_macrophage_cells_clust_res_prefix}{chosen_macrophage_cells_cluster_resolution}")
# Set identity to other clusters
Idents(breast_cancer_patients_macrophage_cells) <- col_macrophage_cells_chosen_cluster

# Generate DimPlot of chosen resolution
macrophage_cells_chosen_resolution_plot <- DimPlot(
  breast_cancer_patients_macrophage_cells,
  reduction = "umap",
  group.by = col_macrophage_cells_chosen_cluster,
  label = TRUE) +
  labs(title = "Macrophage Clusters") &
  NoLegend() &
  NoAxes()
# Print DimPlot chosen resolution
macrophage_cells_plots_to_save[["macrophage_cells_chosen_resolution_plot"]] <- macrophage_cells_chosen_resolution_plot
# Print DimPlots side by side
macrophage_cells_clusters_plus_patient_clusters <-
  macrophage_cells_patient_id_plot + macrophage_cells_chosen_resolution_plot
macrophage_cells_plots_to_save[["macrophage_cells_clusters_plus_patient_clusters"]] <-
  macrophage_cells_clusters_plus_patient_clusters

# Other cells cluster tibble column name
stat_col_macrophage_cells_clusters <- "Macrophage clusters"
# Calculate statistics for the other cells clusters
macrophage_cells_cluster_statistics <- breast_cancer_patients_macrophage_cells@meta.data %>%
  dplyr::rename(!!sym(stat_col_macrophage_cells_clusters) := !!sym(col_macrophage_cells_chosen_cluster)) %>%
  # Group by patient and cluster, then calculate percentage
  group_by(Patient.ID, !!sym(stat_col_macrophage_cells_clusters)) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Patient.ID) %>%
  mutate(Percentage = Count / sum(Count) * 100) %>%
  ungroup() %>%
  # Ensure Patient.ID is a factor
  mutate(Patient.ID = as.factor(Patient.ID))

# Print tibble with the number of cells in each cluster per patient
macrophage_cells_count_clust_patient <- 
  macrophage_cells_cluster_statistics %>%
    # Specify id_cols so the Count column is dropped
    pivot_wider(
      names_from = Patient.ID,
      values_from = Count,
      id_cols = !!sym(stat_col_macrophage_cells_clusters)
  ) %>%
  # Replace NA values with 0 so that the total cells per cluster can be calculated
  mutate(across(2:8, ~replace_na(.x, 0))) %>%
  group_by(!!sym(stat_col_macrophage_cells_clusters)) %>%
  mutate(`Tot. clust. cells` = sum(across(where(is.numeric)))) %>%
  ungroup() %>%
  # Sort according to the Tumor cluster column
  arrange(!!sym(stat_col_macrophage_cells_clusters))
macrophage_cells_plots_to_save[["macrophage_cells_count_clust_patient"]] <-
  macrophage_cells_count_clust_patient

# Plot the distribution of other cell clusters by patient
macrophage_cells_cluster_distribution_plot <- macrophage_cells_cluster_statistics %>%
  # Plot the data
  ggplot(aes(x = Count, y = !!sym(stat_col_macrophage_cells_clusters))) +
  geom_rect(data = unique(macrophage_cells_cluster_statistics["Macrophage clusters"]),
            aes(ymin = as.numeric(`Macrophage clusters`) - 0.4,
                ymax = as.numeric(`Macrophage clusters`) + 0.4,
                xmin = -Inf,
                xmax = Inf),
            fill = "grey90", alpha = 0.3, inherit.aes = FALSE) +
  # Add dots for each patient
  geom_point(aes(color = Patient.ID), size = 3, alpha = 0.7, position = position_dodge(width = 0.7)) +
  theme_minimal() +
  labs(x = "Number of Cells", y = "Cluster", 
       title = "Macrophage Clusters Distribution by Patient",
       color = "Patient") +
  theme(legend.position = "right") +
  scale_color_brewer(palette = "Set1") +
  guides(
    color = guide_legend(order = 1),
  )
macrophage_cells_plots_to_save[["macrophage_cells_cluster_distribution_plot"]] <-
  macrophage_cells_cluster_distribution_plot

print(macrophage_cells_plots_to_save)
```

```{r}
#| label: macrophage-cells-save-plots
#| eval: false

# Save the macrophage cells plots
save_data(macrophage_cells_plots_to_save, file.path(gl_img_dir, "Macrophages clusters"))
```

### Markers

```{r}
#| label: macrophage-cells-markers-load

# Load other cells object from memory
macrophage_cells_markers_list <- readRDS(file.path(gl_obj_dir, "macrophage_cells_markers_list.rds"))
```

```{r}
#| label: macrophage-cells-markers-computation
#| eval: false

# Initialize a list to store marker results for each resolution
macrophage_cells_markers_list <- list()

# Loop over each resolution's cluster metadata column
for (res in macrophage_cells_cluster_seq_res) {
  # Use the group.by parameter to specify the clustering metadata column
  markers <- FindAllMarkers(
    breast_cancer_patients_macrophage_cells,
    group.by = res,
    test.use = "wilcox",
    assay = "SCT",
    only.pos = FALSE,
    random.seed = 5,
    verbose = TRUE)
  
  # Save the markers for the current resolution in the list
  macrophage_cells_markers_list[[res]] <- markers
}
```

```{r}
#| label: macrophage-cells-markers-save
#| eval: false

# Save the data
saveRDS(macrophage_cells_markers_list, file.path(gl_obj_dir, "macrophage_cells_markers_list.rds"))
```

```{r}
#| label: macrophage-cells-markers-plots

# List with data to save
macrophage_cells_markers_to_save <- list()
# List with complex heatmaps
macrophage_cells_complex_heatmaps <- list()

# Loop over each resolution in the list of marker results
for (res in names(macrophage_cells_markers_list)) {
  
  # Print the current resolution being analyzed
  print(paste("Processing resolution:", res))
  
  # Heatmaps title
  macrophage_cells_heatmap_title = paste("Macrophage cells clusters - Resolution:", res)
  
  # Get marker data for the current resolution
  macrophage_cells_markers_df <- macrophage_cells_markers_list[[res]]
  
  # Filter markers to get the most significant up-regulated ones per cluster
  most_significant_macrophage_cells_markers <- macrophage_cells_markers_df %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1 & p_val_adj < 0.05) %>%
    slice_head(n = 10) %>%
    ungroup()
  print(most_significant_macrophage_cells_markers)
  
  # Save the filtered markers for this resolution in the output list
  key_markers <- paste0(res, "_most_significant_markers")
  macrophage_cells_markers_to_save[[key_markers]] <- most_significant_macrophage_cells_markers
  
  ### SEURAT HEATMAP
  # Create a heatmap using the genes from the filtered markers
  macrophage_heatmap_plot <- DoHeatmap(
    breast_cancer_patients_macrophage_cells,
    features = most_significant_macrophage_cells_markers$gene,
    group.by = res,
    assay = "SCT",
    label = TRUE,
    size = 2,
  ) + theme(
    axis.text.y = element_text(size = 5)
  ) + labs(
    title = macrophage_cells_heatmap_title,
    subtitle = "Top 10 Differentially Expressed Genes per Cluster"
  )
  print(macrophage_heatmap_plot)
  
  # Save the heatmap for this resolution in the output list
  macrophage_key_heatmap <- paste0(res, "_heatmap")
  macrophage_cells_markers_to_save[[macrophage_key_heatmap]] <- macrophage_heatmap_plot
  
  ### COMPLEX HEATMAP
  # Unique is used to eliminate duplicated genes, this is done automatically by Seurat DoHeatmap
  unique_macrophage_cells_markers <- unique(most_significant_macrophage_cells_markers$gene)

  # Extract the expression data for the selected genes from the scaled layer
  macrophage_cells_expr_matrix <- as.matrix(
    GetAssayData(
      breast_cancer_patients_macrophage_cells, 
      layer = "scale.data", 
      assay = "SCT"
    )[
      unique_macrophage_cells_markers,
    ]
  )

  # Prepare cell type annotations
  macrophage_cells_clusters <-
    setNames(
      factor(
        as.vector(
          breast_cancer_patients_macrophage_cells@meta.data[[res]]
        )
      ),
      rownames(breast_cancer_patients_macrophage_cells@meta.data))

  # Create vector with unique and sorted cell types
  unique_macrophage_cell_types <- sort(unique(macrophage_cells_clusters))
  
  # Create color palette for cell types
  macrophage_cell_type_colors <- setNames(
    gg_color_hue(length(unique_macrophage_cell_types)),
    unique_macrophage_cell_types
  )

  # Recreate the Seurat expression scale
  palette_macrophage_expression_level = circlize::colorRamp2(c(
    min(macrophage_cells_expr_matrix),
    median(macrophage_cells_expr_matrix),
    min(2.5, max(macrophage_cells_expr_matrix))),
    c("#FF00FF", "#000000", "#FFFF00"))

  # Create the heatmap with ComplexHeatmap
  macrophage_cells_clust_diff_expr_genes_complex_heatmap <- Heatmap(
    matrix = macrophage_cells_expr_matrix,
    row_order = unique_macrophage_cells_markers,
    name = "expression",
    column_split = factor(macrophage_cells_clusters, levels = unique_macrophage_cell_types),
    # Do not cluster rows or columns otherwise row_order/column_order are ignored
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    column_title_rot = 0,
    show_column_names = FALSE,
    show_column_dend = FALSE,
    show_row_names = TRUE,
    show_row_dend = FALSE,
    cluster_column_slices = TRUE,
    column_gap = unit(0.5, "mm"),
    row_names_gp = gpar(fontsize = 5),
    # The column title can be either a title for all the columns or a vector with a name for every column
    column_title = unique_macrophage_cell_types,
    column_title_gp = gpar(fontsize = 7),
    # Add the annotation bars on top
    top_annotation = HeatmapAnnotation(
      # Give a name to the annotation, not used on the actual plot
      name = "Clusters",
      # Annotate the columns
      which = "column",
      # First annotation - clusters
      cluster = macrophage_cells_clusters,
      # Second annotation - patients
      patient = breast_cancer_patients_macrophage_cells@meta.data$Patient.ID,
      # Color palettes
      col = list(cluster = cell_type_colors, patient = palette_patients),
      show_legend = c(FALSE, TRUE),
      gap = unit(1, "mm"),
      simple_anno_size = unit(2, "mm"),
      annotation_name_gp = gpar(fontsize = 6)
    ),
    # Color scale for expression
    col = palette_macrophage_expression_level,
    # Otherwise you get random vertical white lines where there should not be any
    use_raster = FALSE
  )
  # Put the legends on the right in a single column
  draw(
    object = macrophage_cells_clust_diff_expr_genes_complex_heatmap,
    merge_legend = TRUE,
    column_title = macrophage_cells_heatmap_title)
  
  # Save the heatmap for this resolution in the output list
  macrophage_key_complex_heatmap <- paste0(res, "_complex_heatmap")
  macrophage_cells_complex_heatmaps[[macrophage_key_complex_heatmap]] <- recordPlot()
  macrophage_cells_markers_to_save <- c(macrophage_cells_markers_to_save, macrophage_cells_complex_heatmaps)
}
```

```{r}
#| label: macrophage-cells-markers-save
#| eval: false

# Other cells markers folder
macrophage_cells_markers_dir <- file.path(gl_img_dir, "Macrophages markers")
# Define and set complex heatmap attributes
macrophage_cells_complex_heatmap_attrs <- list(width = 18, height = 13, units = "cm", dpi = 600)
macrophage_cells_markers_to_save <- set_plot_attributes(
  list_name = macrophage_cells_markers_to_save,
  attr_list = macrophage_cells_complex_heatmap_attrs,
  plot_names = names(macrophage_cells_complex_heatmaps))
# Save the data
save_data(macrophage_cells_markers_to_save, macrophage_cells_markers_dir)
```

### Pseudotime

```{r}
#| label: macrophage-cells-markers-load

# Load other cells object from memory
macrophage_cds <- readRDS(file.path(gl_obj_dir, "macrophage_cds.rds"))
```

```{r}
#| label: macrophage-cells-pseudotime
#| eval: false

# Create a monocle3 object from Seurat
macrophage_cds <- as.cell_data_set(breast_cancer_patients_macrophage_cells)

### MANUALLY ASSIGN MONOCLE3 OBJECT METADATA FROM SEURAT OBJECT
# Assign partitions manually, all the clusters should be part of the same partition
# Create a vector with the same length as the number of cells and value 1 as the partition number
macrophage_partition <- c(rep(1,length(macrophage_cds@colData@rownames)))
# Assign cell names to the partition vector
names(macrophage_partition) <- macrophage_cds@colData@rownames
# Convert the partition vector to a factor
macrophage_partition <- as.factor(macrophage_partition)
# Assign the partition to the Monocle3 object
macrophage_cds@clusters$UMAP$partitions <- macrophage_partition

# Assign the cluster info from Seurat
macrophage_cds@clusters$UMAP$clusters <- breast_cancer_patients_macrophage_cells@active.ident

# Assign UMAP coordinate - cell embeddings from Seurat
macrophage_cds@int_colData@listData$reducedDims$UMAP <- breast_cancer_patients_macrophage_cells@reductions$umap@cell.embeddings

### RUN MONOCLE3 ANALYSIS
# Learn trajectory graph
macrophage_cds <- learn_graph(
  cds = macrophage_cds,
  use_partition = TRUE,
  verbose = TRUE)
# Order cells according to pseudotime
macrophage_pseudotime_start_cluster <- 3
macrophage_cds <- order_cells(
  cds = macrophage_cds,
  reduction_method = 'UMAP',
  root_cells = colnames(macrophage_cds[,monocle3::clusters(macrophage_cds) == macrophage_pseudotime_start_cluster]))

# Save pseudotime back to Seurat object
breast_cancer_patients_macrophage_cells$pseudotime <- pseudotime(macrophage_cds)
```

```{r}
#| label: macrophage-cells-pseudotime-save
#| eval: false

# Save the data
saveRDS(macrophage_cds, file.path(gl_obj_dir, "macrophage_cds.rds"))
```

```{r}
#| label: macrophage-cells-save-rds
#| eval: false

# Save the Seurat object
saveRDS(breast_cancer_patients_macrophage_cells, file.path(gl_obj_dir, "breast_cancer_patients_macrophage_cells.rds"))
```

```{r}
#| label: macrophage-cells-pseudotime-plot

# List of images
macrophage_cells_pseudotime_images <- list()

# Same color palette as Seurat
library(scales)
palette_macrophage_cells <- hue_pal()(length(unique(colData(macrophage_cds)$ident)))
# Plot the cell trajectory
macrophages_cell_trajectory <- 
  plot_cells(
    cds = macrophage_cds,
    color_cells_by = 'cluster',
    cell_size = 1.5,
    label_groups_by_cluster = FALSE,
    label_branch_points = FALSE,
    label_roots = FALSE,
    label_leaves = FALSE,
    group_label_size = 6,
    cell_stroke = 0
  ) +
  scale_color_manual(
    values = palette_macrophage_cells
  ) +
  theme_void() +
  theme(legend.position = "none") +
  labs(title = "Macrophages Trajectory Plot")
macrophage_cells_pseudotime_images[["macrophages_cell_trajectory"]] <- macrophages_cell_trajectory
# Plot pseudotime
macrophages_pseudotime <- plot_cells(
  cds = macrophage_cds,
  color_cells_by = "pseudotime",
  show_trajectory_graph = TRUE,
  cell_size = 1,
  cell_stroke = 0
) +
  theme_void() +
  theme(legend.position = "none") +
  labs(title = "Macrophages Pseudotime")
macrophage_cells_pseudotime_images[["macrophages_pseudotime"]] <- macrophages_pseudotime

# Print images
print(macrophage_cells_pseudotime_images)
```

```{r}
#| label: macrophage-cells-pseudotime-save-plots
#| eval: false

# Save the macrophage cells plots
save_data(macrophage_cells_pseudotime_images, file.path(gl_img_dir, "Macrophages clusters"))
```

## Other cells

### Cluster

```{r}
#| label: other-cells-load

# Load other cells object from memory
breast_cancer_patients_other_cells <- readRDS(file.path(gl_obj_dir, "breast_cancer_patients_other_cells.rds"))
```

```{r}
#| label: other-cells-metadata-columns

# Name of the metadata column with the other clusters
col_other_cells_clust_res_prefix <- "other_cells_clusters_res_"
# Find clusters of other cells
# The default resolution is 1, increase it to get more clusters or decrease it to get fewer clusters
# Try a range of resolutions
other_cells_seq_res <- seq(0.1, 0.4, by = 0.1)
# Create custom cluster names based on the actual resolution values
other_cells_cluster_seq_res <- glue::glue("{col_other_cells_clust_res_prefix}{other_cells_seq_res}")
```

```{r}
#| label: other-cells-compute
#| eval: false

# After subsetting a Seurat object it is good to normalize it again
breast_cancer_patients_other_cells <- SCTransform(
  breast_cancer_patients_other_cells,
  return.only.var.genes = FALSE,
  assay = "RNA",
  new.assay.name = "SCT",
  verbose = TRUE)

# Run PCA
breast_cancer_patients_other_cells <- RunPCA(
  breast_cancer_patients_other_cells,
  reduction.key = "PC_",
  reduction.name = "pca",
  seed.use = 42,
  verbose = TRUE)
# Generate variance elbow plots
generate_variance_elbow_plots(breast_cancer_patients_other_cells, "pca", 50)
# Dimension to use for subsequent analysis, decided lokking at the elbow plot
other_cells_dims <- 1:23
# Find neighbors of other cells
# Number of PCA dimensions used in Seurat's FindNeighbors function
#
# Using MORE dimensions:
# Captures more subtle biological variation
# Includes more complex relationships between genes
# May include more noise/technical artifacts
# Computationally more intensive
#
# Using FEWER dimensions:
# Focuses on major sources of variation
# More robust to technical noise
# May miss subtle biological signals
# Computationally faster
breast_cancer_patients_other_cells <- FindNeighbors(
  breast_cancer_patients_other_cells,
  reduction = "pca",
  dims = other_cells_dims,
  verbose = TRUE)

# Find clusters at different resolutions
breast_cancer_patients_other_cells <- FindClusters(
  breast_cancer_patients_other_cells,
  resolution = other_cells_seq_res,
  cluster.name = other_cells_cluster_seq_res,
  random.seed = 5,
  verbose = TRUE)

# Run UMAP
breast_cancer_patients_other_cells <- RunUMAP(
  breast_cancer_patients_other_cells,
  reduction = "pca",
  reduction.key = "UMAP_",
  reduction.name = "umap",
  dims = other_cells_dims,
  verbose = TRUE,
  seed.use = 42)
```

### Plot

```{r}
#| label: other-cells-plot

other_cells_plots_to_save <- list()

# View UMAP with other cells at different clustering resolutions
other_cells_different_resolutions <- DimPlot(
  breast_cancer_patients_other_cells,
  reduction = "umap",
  ncol = 2,
  group.by = other_cells_cluster_seq_res,
  label = TRUE,
  ) & 
  NoLegend() & 
  NoAxes() & 
  theme(
  plot.margin = unit(c(0, 0, 0, 0), "lines"),
  plot.title = element_text(size = 12, face = "bold")
  )
other_cells_plots_to_save[["other_cells_different_resolutions"]] <- other_cells_different_resolutions

# View UMAP with other cells and patient clusters
other_cells_patient_id_plot <- DimPlot(
  breast_cancer_patients_other_cells,
  reduction = "umap",
  label = TRUE,
  label.box=TRUE,
  group.by = "Patient.ID",
  cols = palette_patients) +
  labs(title = "Patient ID clusters") &
  NoLegend() &
  NoAxes()
other_cells_plots_to_save[["other_cells_patient_id_plot"]] <- other_cells_patient_id_plot

# Chosen resolution
chosen_other_cells_cluster_resolution <- 0.2
# Chosen cluster
col_other_cells_chosen_cluster <- glue::glue("{col_other_cells_clust_res_prefix}{chosen_other_cells_cluster_resolution}")
# Set identity to other clusters
Idents(breast_cancer_patients_other_cells) <- col_other_cells_chosen_cluster

# Generate DimPlot of chosen resolution
other_cells_chosen_resolution_plot <- DimPlot(
  breast_cancer_patients_other_cells,
  reduction = "umap",
  group.by = col_other_cells_chosen_cluster,
  label = TRUE) +
  labs(title = "Other Cell Clusters") &
  NoLegend() &
  NoAxes()
# Print DimPlot chosen resolution
other_cells_plots_to_save[["other_cells_chosen_resolution_plot"]] <- other_cells_chosen_resolution_plot
# Print DimPlots side by side
other_cells_clusters_plus_patient_clusters <- other_cells_patient_id_plot + other_cells_chosen_resolution_plot
other_cells_plots_to_save[["other_cells_clusters_plus_patient_clusters"]] <- other_cells_clusters_plus_patient_clusters

# Generate FeaturePlot of other clusters
# max.cutoff q95 is set so any values above the 95th percentile will be set to the 95th percentile value,
# this helps prevent extreme outliers from dominating the color scale
# min.cutoff 0 is set so any positive value will be highlighted
other_cells_feature_plot <- (FeaturePlot(
  object = breast_cancer_patients_other_cells,
  reduction = "umap",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  max.cutoff = "q95",
  min.cutoff = 0,
  label = TRUE) &
  NoAxes()) +
  plot_annotation(title = "Other Cells")
other_cells_plots_to_save[["other_cells_feature_plot"]] <- other_cells_feature_plot

# Other cells cluster tibble column name
stat_col_other_cells_clusters <- "Other cell clusters"
# Calculate statistics for the other cells clusters
other_cells_cluster_statistics <- breast_cancer_patients_other_cells@meta.data %>%
  dplyr::rename(!!sym(stat_col_other_cells_clusters) := !!sym(col_other_cells_chosen_cluster)) %>%
  # Group by patient and cluster, then calculate percentage
  group_by(Patient.ID, !!sym(stat_col_other_cells_clusters)) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Patient.ID) %>%
  mutate(Percentage = Count / sum(Count) * 100) %>%
  ungroup() %>%
  # Ensure Patient.ID is a factor
  mutate(Patient.ID = as.factor(Patient.ID))

# Print tibble with the percentages of cells in each cluster per patient
other_cells_percent_clust_patient <- other_cells_cluster_statistics %>%
  # Specify id_cols so the Count column is dropped
  pivot_wider(names_from = Patient.ID, values_from = Percentage, id_cols = !!sym(stat_col_other_cells_clusters)) %>%
  # Round the values to two decimal places
  mutate(across(2:8, \(x) round(x, 2))) %>%
  # Sort according to the Tumor cluster column
  arrange(!!sym(stat_col_other_cells_clusters))
other_cells_plots_to_save[["other_cells_percent_clust_patient"]] <- other_cells_percent_clust_patient

# Print tibble with the count of cells in each cluster per patient
other_cells_count_clust_patient <- other_cells_cluster_statistics %>%
  # Specify id_cols so the Percentage column is dropped
  pivot_wider(names_from = Patient.ID, values_from = Count, id_cols = !!sym(stat_col_other_cells_clusters)) %>%
  # Replace NA values with 0 so that the total cells per cluster can be calculated
  mutate(across(2:8, ~replace_na(.x, 0))) %>%
  group_by(!!sym(stat_col_other_cells_clusters)) %>%
  mutate(`Tot. clust. cells` = sum(across(where(is.numeric)))) %>%
  ungroup() %>%
  arrange(!!sym(stat_col_other_cells_clusters))
other_cells_plots_to_save[["other_cells_count_clust_patient"]] <- other_cells_count_clust_patient

# Plot the distribution of other cell clusters by patient
other_cells_cluster_distribution_plot <- other_cells_cluster_statistics %>%
  # Plot the data
  ggplot(aes(x = Percentage, y = !!sym(stat_col_other_cells_clusters))) +
  # Add dots for each patient
  geom_point(aes(color = Patient.ID), size = 3, alpha = 0.7) +
  theme_minimal() +
  labs(x = "Percentage of Cells", y = "Cluster", 
       title = "Other Cell Clusters Distribution by Patient",
       color = "Patient") +
  theme(legend.position = "right") +
  scale_color_brewer(palette = "Set1") +
  guides(
    color = guide_legend(order = 1),
  )
other_cells_plots_to_save[["other_cells_cluster_distribution_plot"]] <- other_cells_cluster_distribution_plot

# Identify genes in the SCT assay that start with "KRT"
# These should be the genes that contributes the most to the gene expression
# measured by the antibody panCK
krt_genes <- grep("^KRT", rownames(breast_cancer_patients_other_cells[["SCT"]]), value = TRUE)
# Calculate the average expression of the KRT genes for each cell
krt_avg_expression <- Matrix::colMeans(
  breast_cancer_patients_other_cells[["SCT"]]@data[krt_genes, ])
# Add the average expression as a new metadata column
breast_cancer_patients_other_cells$KRT_Avg_Expression <- krt_avg_expression

# Visualize the co-expression of the KRT genes and the panCK antibody
KRT_panCK_coexpression <- (FeaturePlot(
  breast_cancer_patients_other_cells,
  reduction = "umap",
  max.cutoff = "q95",
  min.cutoff = 0,
  features = c("Mean.PanCK", "KRT_Avg_Expression"),
  blend = TRUE
)  & NoAxes()) + 
  plot_layout(ncol = 2) +
  theme(plot.title = element_text(hjust = 0.5))
KRT_panCK_coexpression[[1]] <-
  KRT_panCK_coexpression[[1]] + 
  labs(title = "PanCK", subtitle = "Mean expression")
KRT_panCK_coexpression[[2]] <-
  KRT_panCK_coexpression[[2]] + 
  labs(title = "KRT genes", subtitle = "Mean expression")
KRT_panCK_coexpression[[3]] <-
  KRT_panCK_coexpression[[3]] + 
  labs(title = "PanCK & KRT genes", subtitle = "Co-expression")
other_cells_plots_to_save[["KRT_panCK_coexpression"]] <- KRT_panCK_coexpression

# Violin plot with the expression of panCK, CD45 and CD68 for each Insitutype clusters
other_cells_clust_protein_expr <- VlnPlot(
  breast_cancer_patients_other_cells,
  assay = "SCT",
  layer = "data",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  pt.size = 0,
  group.by = col_other_cells_chosen_cluster,
  combine = FALSE
)
other_cells_clust_protein_expr <- lapply(
  other_cells_clust_protein_expr,
  function(x) x & NoLegend() & labs(subtitle = "Other Clusters"))
names(other_cells_clust_protein_expr) <- glue('Other_cells_{c("PanCK", "CD45", "CD68")}')
other_cells_plots_to_save <- c(other_cells_plots_to_save, other_cells_clust_protein_expr)

# Calculate the mean of CD45, CD68 and PanCK for each Insitutype cluster
other_cells_cluster_protein_statistics <- breast_cancer_patients_other_cells@meta.data %>%
  group_by(!!sym(col_other_cells_chosen_cluster)) %>%
  summarise(
    `Mean PanCK` = mean(Mean.PanCK),
    `Mean CD45` = mean(Mean.CD45),
    `Mean CD68` = mean(Mean.CD68),
    .groups = "drop"
  ) %>%
  arrange(desc(`Mean PanCK`))
other_cells_plots_to_save[["other_cells_cluster_protein_statistics"]] <- other_cells_cluster_protein_statistics

print(other_cells_plots_to_save)
```

```{r}
#| label: other-cells-save-plots
#| eval: false

# Save the other cells plots
save_data(other_cells_plots_to_save, file.path(gl_img_dir, "Other cells clusters"))
```

```{r}
#| label: other-cells-save-rds
#| eval: false

# Save the Seurat object
saveRDS(breast_cancer_patients_other_cells, file.path(gl_obj_dir, "breast_cancer_patients_other_cells.rds"))
```

### Markers

```{r}
#| label: other-cells-markers-load

# Load other cells object from memory
other_cells_markers_data <- readRDS(file.path(gl_obj_dir, "other_cells_markers_data.rds"))
```

```{r}
#| label: other-cells-markers-computation
#| eval: false

# Find all markers of the other clusters
# GSEA needs both positive and negative markers
other_cells_markers_data <- FindAllMarkers(
  breast_cancer_patients_other_cells,
  test.use = "wilcox",
  assay = "SCT",
  only.pos = FALSE,
  random.seed = 5,
  verbose = TRUE)
```

```{r}
#| label: other-cells-markers-save
#| eval: false

# Save the data
saveRDS(other_cells_markers_data, file.path(gl_obj_dir, "other_cells_markers_data.rds"))
```


```{r}
#| label: other-cells-markers-plots

# List with data to save
other_cells_markers_to_print <- list()

# Filter markers to get the most significant up-regulated ones per cluster
most_significant_other_cells_markers <- other_cells_markers_data %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1 & p_val_adj < 0.05) %>%
  slice_head(n = 10) %>%
  ungroup()
other_cells_markers_to_print[["most_significant_other_cells_markers"]] <- most_significant_other_cells_markers

other_cells_clust_diff_expr_genes_heatmap <- DoHeatmap(
    breast_cancer_patients_other_cells,
    features = most_significant_other_cells_markers$gene,
    assay = "SCT",
    label = TRUE,
    size = 2
    #group.colors = color_lookup_table,
   ) + theme(
     axis.text.y = element_text(size = 5),
   ) + labs(
     title = paste("Other cells clusters"),
     subtitle = "Top 10 Differentially Expressed Genes per Cluster"
   )
other_cells_markers_to_print[["other_clust_diff_expr_genes_heatmap"]] <- other_cells_clust_diff_expr_genes_heatmap

print(other_cells_markers_to_print)
```

```{r}
#| label: other-cells-markers-complex-heatmap

# Info to save
other_cells_complex_heatmap_list <- list()

# Unique is used to eliminate duplicated genes, this is done automatically by Seurat DoHeatmap
features <- unique(most_significant_other_cells_markers$gene)

# Extract the expression data for the selected genes from the scaled layer
other_cells_expr_matrix <- as.matrix(
  GetAssayData(
    breast_cancer_patients_other_cells, 
    layer = "scale.data", 
    assay = "SCT"
  )[
    features,
  ]
)

# Prepare cell type annotations
other_cells_clusters <- Idents(breast_cancer_patients_other_cells)
# Create vector with unique and sorted cell types
unique_cell_types <- sort(unique(other_cells_clusters))

# Create color palette for cell types
cell_type_colors <- setNames(
  gg_color_hue(length(unique_cell_types)),
  unique_cell_types
)

# Recreate the Seurat expression scale
palette_expression_level = circlize::colorRamp2(
  c(min(other_cells_expr_matrix), median(other_cells_expr_matrix), min(2.5, max(other_cells_expr_matrix))),
  c("#FF00FF", "#000000", "#FFFF00"))

# Create the heatmap with ComplexHeatmap
other_cells_clust_diff_expr_genes_complex_heatmap <- Heatmap(
  matrix = other_cells_expr_matrix,
  row_order = features,
  name = "expression",
  column_split = factor(other_cells_clusters, levels = unique_cell_types),
  # Do not cluster rows or columns otherwise row_order/column_order are ignored
  cluster_rows = FALSE,
  cluster_columns = FALSE,
  column_title_rot = 0,
  show_column_names = FALSE,
  show_column_dend = FALSE,
  show_row_names = TRUE,
  show_row_dend = FALSE,
  cluster_column_slices = TRUE,
  column_gap = unit(0.5, "mm"),
  row_names_gp = gpar(fontsize = 5),
  # The column title can be either a title for all the columns or a vector with a name for every column
  column_title = unique_cell_types,
  column_title_gp = gpar(fontsize = 7),
  # Add the annotation bars on top
  top_annotation = HeatmapAnnotation(
    # Give a name to the annotation, not used on the actual plot
    name = "Clusters",
    # Annotate the columns
    which = "column",
    # First annotation - clusters
    cluster = other_cells_clusters,
    # Second annotation - patients
    patient = breast_cancer_patients_other_cells@meta.data$Patient.ID,
    # Color palettes
    col = list(cluster = cell_type_colors, patient = palette_patients),
    show_legend = c(FALSE, TRUE),
    gap = unit(1, "mm"),
    simple_anno_size = unit(2, "mm"),
    annotation_name_gp = gpar(fontsize = 6)
  ),
  # Color scale for expression
  col = palette_expression_level,
  # Otherwise you get random vertical white lines where there should not be any
  use_raster = FALSE
)
# Put the legends on the right in a single column
draw(other_cells_clust_diff_expr_genes_complex_heatmap, merge_legend = TRUE)

other_cells_complex_heatmap_list[["other_cells_clust_diff_expr_genes_complex_heatmap"]] <- recordPlot()
```

```{r}
#| label: other-cells-featureplot-markers

# Info to print
main_markers_list <- list()

# Create vector with the main marker from every cluster
other_cells_clusters_main_markers <- most_significant_other_cells_markers %>%
  group_by(cluster) %>%
  dplyr::slice(1) %>%
  ungroup() %>%
  pull(gene)

# Create a feature plot for each marker
other_cells_main_markers_feature_plot <- FeaturePlot(
  object = breast_cancer_patients_other_cells,
  features = other_cells_clusters_main_markers,
  reduction = "umap"
  ) & 
  NoLegend() &
  NoAxes()

# Create a subtitle for every plot in the patchwork with the number of the cluster
for (i in 1:length(other_cells_clusters_main_markers)) {
  other_cells_main_markers_feature_plot[[i]] <- 
    other_cells_main_markers_feature_plot[[i]] + labs(subtitle = glue("cluster {i-1}"))
}

main_markers_list[["other_cells_main_markers_feature_plot"]] <- other_cells_main_markers_feature_plot

# Select custom markers
other_cells_clusters_custom_markers <- c(
  "MMP7",
  "LYZ",
  "APOD",
  "AGR2",
  "IFI6",
  "ERBB2",
  "LTF",
  "APOE",
  "EGFR",
  "IGFBP7")

# Create a feature plot for each marker
other_cells_custom_markers_feature_plot <- FeaturePlot(
  object = breast_cancer_patients_other_cells,
  features = other_cells_clusters_custom_markers,
  reduction = "umap"
  ) & 
  NoLegend() &
  NoAxes()

# Create a subtitle for every plot in the patchwork with the number of the cluster
for (i in 1:length(other_cells_clusters_custom_markers)) {
  other_cells_custom_markers_feature_plot[[i]] <-
    other_cells_custom_markers_feature_plot[[i]] + labs(subtitle = glue("cluster {i-1}"))
}

main_markers_list[["other_cells_custom_markers_feature_plot"]] <- other_cells_custom_markers_feature_plot

# Print the info
print(main_markers_list)
```

```{r}
#| label: other-cells-markers-save
#| eval: false

# Other cells markers folder
other_cells_markers_dir <- file.path(gl_img_dir, "Other cells markers")
# Save the markers
save_data(other_cells_markers_to_print, other_cells_markers_dir)

# Define and set complex heatmap attributes
complex_heatmap_attrs <- list(width = 15, height = 20, units = "cm", dpi = 1000)
other_cells_complex_heatmap_list <- set_plot_attributes(other_cells_complex_heatmap_list, complex_heatmap_attrs)
# Save ComplexHeatmap
save_data(other_cells_complex_heatmap_list, other_cells_markers_dir)

# Save markers
save_data(main_markers_list, other_cells_markers_dir)
```

## All cells

Combine the metadata from the various subsets and print a new UMAP with all the cells

```{r}
#| label: all-cells-metadata-columns

# Name of the metadata column
col_other_cells_ann <- "other_clusters_ann"
col_tumor_cells_ann <- "tumor_clusters_ann"
col_ist_merge_type <- "cell_final_type"
col_ist_merge_group <- "cell_final_group"
```

```{r}
#| label: all-cells-metadata-add

# Create metadata column distinguishing between tumor and other (unknown) cells
# Cluster 7 is annotated as unknown as it is not 100% clear if it is a tumor cluster
breast_cancer_patients_other_cells@meta.data %<>%
  mutate("{col_other_cells_ann}" := case_match(
  get(col_other_cells_chosen_cluster),
  "7" ~ "Unknown",
  .default = "Tumor",
))

# Create metadata column with all the tumor subclusters
breast_cancer_patients_other_cells@meta.data %<>%
  mutate("{col_tumor_cells_ann}" := case_match(
  get(col_other_cells_ann),
  "Tumor" ~ glue("Tumor {get(col_other_cells_chosen_cluster)}"),
  .default = .data[[col_other_cells_ann]],
))

## CELL TYPES

# Add other cells clusters to analyze object
breast_cancer_patients_analyze <- AddMetaData(
  object = breast_cancer_patients_analyze,
  metadata = FetchData(
    object = breast_cancer_patients_other_cells,
    vars = col_other_cells_ann),
  col.name = col_other_cells_ann
)

# Merge the other cells clusters with the insitutype clusters
breast_cancer_patients_analyze@meta.data %<>%
mutate("{col_ist_merge_type}" := if_else(
    get(col_ist_ann) != "Other",
    get(col_ist_ann),
    get(col_other_cells_ann)
))

# Merge the ist cells groups with the tumor groups
breast_cancer_patients_analyze@meta.data %<>%
mutate("{col_ist_merge_group}" := if_else(
    get(col_cell_group) != "Other",
    get(col_cell_group),
    get(col_other_cells_ann)
))
```

```{r}
#| label: all-cells-plot

# List to save data
all_cells_images <- list()

# Print UMAP with final cell types
all_cell_types_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_ist_merge_type,
  reduction = "sct_umap_patients",
  cols = palette_cell_types) +
  labs(title = "Insitutype clusters") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      ncol=1,
      keywidth = unit(0.5, "lines"),
      keyheight = unit(0.8, "lines"),
      spacing = unit(0.2, "lines"))
  ) +
  theme_classic(base_size = 9) &
  NoAxes()
all_cells_images[["all_cell_types_sct_plot"]] <- all_cell_types_sct_plot

# Print UMAP with final cell groups
all_cell_groups_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_ist_merge_group,
  reduction = "sct_umap_patients",
  cols = palette_cell_types) +
  labs(title = "Final cell groups") &
  NoAxes()
all_cells_images[["all_cell_groups_sct_plot"]] <- all_cell_groups_sct_plot

# Tibble with mean protein data for the cell groups
all_cell_mean_proteins <- breast_cancer_patients_analyze@meta.data %>%
  group_by(!!sym(col_ist_merge_group)) %>%
  summarise(
    `Mean PanCK` = mean(Mean.PanCK),
    `Mean CD45` = mean(Mean.CD45),
    `Mean CD68` = mean(Mean.CD68),
    .groups = "drop"
  )
all_cells_images[["all_cell_mean_proteins"]] <- all_cell_mean_proteins

plot_proteins_all_cells <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "SCT",
  layer = "data",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  pt.size = 0,
  group.by = col_ist_merge_group,
  cols = palette_cell_types,
  combine = FALSE
)
plot_proteins_all_cells <- lapply(
  plot_proteins_all_cells,
  function(x) x & NoLegend() & labs(subtitle = "Cell groups"))
names(plot_proteins_all_cells) <- glue('Final_groups_{c("PanCK", "CD45", "CD68")}')
all_cells_images <- c(all_cells_images, plot_proteins_all_cells)

print(all_cells_images)
```

```{r}
#| label: all-cells-save-data
#| eval: false

# Save the data
save_data(all_cells_images, file.path(gl_img_dir, "All cells annotated"))
```

## Gene Set Enrichment Analysis

### GSEA objects

```{r}
#| label: gsea-load-objects

# Load the GSEA results
GSEA_results <- readRDS(file.path(gl_obj_dir, "GSEA_results.rds"))
```

```{r}
#| label: gsea-create-objects
#| eval: false

# Set default assay to RNA
DefaultAssay(breast_cancer_patients_other_cells) <- "RNA"

# Set the colors for the p adjust gradient bar
max_color <- rgb(238, 197, 194, maxColorValue = 255)
min_color <- rgb(215, 102, 86, maxColorValue = 255)
options(enrichplot.colours = c(min_color, max_color))

# List to save the GSEA results
GSEA_results <- list()
# Run GSEA for each tumor cluster
for (cluster in levels(breast_cancer_patients_other_cells)) {
  tumor_cluster_number <- cluster
  print(paste("Running GSEA analysis for cluster:", tumor_cluster_number))
  
  # Get the markers for the tumor cluster
  other_cells_cluster_markers <- other_cells_markers_data %>%
    dplyr::filter(cluster == tumor_cluster_number)
  
  # How to create the gene list
  # http://yulab-smu.top/biomedical-knowledge-mining-book/faq.html#genelist
  # Gene list creation
  gsea_gene_list <- other_cells_cluster_markers %>%
    dplyr::mutate(rank = rank(avg_log2FC, ties.method = "random")) %>%
    dplyr::arrange(desc(rank)) %>%
    with(setNames(avg_log2FC, gene))
  
  # Run GSEA
  gsea <- gseGO(geneList     = gsea_gene_list,
                    keyType      = "SYMBOL",
                    OrgDb        = org.Hs.eg.db, 
                    ont          = "BP",
                    minGSSize    = 10,
                    maxGSSize    = 500,
                    pvalueCutoff = 0.05,
                    verbose      = TRUE,
                    pAdjustMethod = "fdr")
  # Save the GSEA results
  GSEA_results[[tumor_cluster_number]] <- gsea
}

# Save the GSEA results
saveRDS(GSEA_results, file.path(gl_obj_dir, "GSEA_results.rds"))
```

### GSEA plots

```{r}
#| message: false
#| warning: false
#| fig-width: 9
#| fig-height: 6
# Disable messages and warnings so they do not appear above the first image generated by the loop
# Make images bigger so they are easier to read

# Create a list of gene counts for each cluster
cluster_gene_stats <- list()
for (cluster in levels(breast_cancer_patients_other_cells)) {
  tumor_cluster_markers <- other_cells_markers_data %>%
    dplyr::filter(cluster == !!cluster)
  
  # Calculate gene counts and save them in a list
  cluster_gene_stats[[cluster]] <- list(
    num_upreg_genes = tumor_cluster_markers %>%
      dplyr::filter(avg_log2FC > 0, p_val < 0.05) %>%
      nrow(),
    num_downreg_genes = tumor_cluster_markers %>%
      dplyr::filter(avg_log2FC < 0, p_val < 0.05) %>%
      nrow()
  )
}

# Lists to save plots and tibbles
GSEA_plots <- list()
GSEA_tibbles <- list()

GSEA_to_plot <- list()
# GSEA plots with results
for (cluster in names(GSEA_results)) {
  gsea <- GSEA_results[[cluster]]
  # If there are results
  if (nrow(gsea@result) > 0) {
    GSEA_to_plot[[cluster]] <- GSEA_results[[cluster]]
  }
}
# Print the names of the clusters with GSEA results
print(names(GSEA_to_plot))

# Simplify values for the GSEA plots
GSEA_plot_simply_cutoff <- c(
  "4" = 0.5,
  "5" = 0.5,
  "8" = 1)
# Create plots and tibbles
# Do not plot if no pathways have been found
for (cluster in names(GSEA_to_plot)) {
  gsea <- GSEA_to_plot[[cluster]]
  # Simplify GSEA results by grouping together or eliminating terms that are very similar or redundant
  gsea_simplified <- clusterProfiler::simplify(gsea, cutoff = GSEA_plot_simply_cutoff[[cluster]])
  gene_stats <- cluster_gene_stats[[cluster]]
  num_upreg_genes <- gene_stats$num_upreg_genes
  num_downreg_genes <- gene_stats$num_downreg_genes
  
  # Prepare plot labels
  GSEAlabels <- labs(
    title = paste("Significant Pathways in Tumor Cluster", cluster), 
    subtitle = "by Gene Set Enrichment Analysis",
    caption = paste0("Based on ", num_upreg_genes, " up-regulated genes and ", num_downreg_genes, " down-regulated genes.")
  )
  # Prepare plot aesthetics
  GSEAtheme <- theme(
    plot.title = element_text(hjust = 0.5, size = 20),
    plot.subtitle = element_text(hjust = 0.5, size = 15),
    axis.text.x = element_text(angle = 0, size = 10),
    axis.text.y = element_text(angle = 0, size = 6)
  ) 
  # Make the GSEA plot
  GSEADotPlot <- dotplot(gsea_simplified, showCategory = 25) +
    GSEAlabels + labs(x = "Gene Ratio", y = "Biological Pathway") +
    GSEAtheme
  
  # Save the plot and tibble
  GSEA_plots[[glue("GSEA Tumor cluster {cluster}")]] <- GSEADotPlot
  GSEA_tibbles[[glue("GSEA Tumor cluster {cluster}")]] <- as_tibble(gsea_simplified@result)
}
```

```{r}
#| label: gsea-plots

# Display the GSEA plots
print(GSEA_plots)
```

```{r}
#| label: gsea-tibbles

# Display the GSEA tibbles
print(GSEA_tibbles)
```

```{r}
#| label: gsea-save
#| eval: false

# Save the GSEA plots
save_data(GSEA_plots, file.path(gl_img_dir, "GSEA plots"))
# Save the GSEA tibbles
save_data(GSEA_tibbles, file.path(gl_img_dir, "GSEA tables"))
# Save the GSEA results
saveRDS(GSEA_results, file.path(gl_obj_dir, "GSEA_results.rds"))
```


## Merge

Merge normal and tumor subclusters

```{r}
#| label: merge-cells-metadata-columns

# Name of metadata column with all cell types and tumor subtypes
col_cell_tumor_cluster_subtype <- "cell_final_subtype"
```

```{r}
#| label: merge-cells-metadata-add
#| eval: false

# Copy the metadata for the tumor cells
breast_cancer_patients_analyze <- AddMetaData(
  object = breast_cancer_patients_analyze,
  metadata = FetchData(
    object = breast_cancer_patients_other_cells,
    vars = col_tumor_cells_ann),
  col.name = col_tumor_cells_ann
)


# Merge the insitutype phenotyping with the tumor clusters
breast_cancer_patients_analyze@meta.data %<>%
  mutate("{col_cell_tumor_cluster_subtype}" := if_else(
    get(col_ist_ann) != "Other",
    get(col_ist_ann),
    get(col_tumor_cells_ann)
    )
  )
```

```{r}
#| label: merge-cells-info

# Create a tibble with cell count and percentage of every cluster
cell_types_count <- breast_cancer_patients_analyze@meta.data %>%
  count(.data[[col_cell_tumor_cluster_subtype]], name = "cell_count") %>%
  mutate(percentage = round((cell_count / sum(cell_count)) * 100, 3)) %>%
  dplyr::rename(cluster = .data[[col_cell_tumor_cluster_subtype]]) %>%
  as_tibble()
# Print the tibble as an html widget that can be sorted
datatable(cell_types_count)
```

## Spatial plots of clusters

Plot the spatial distribution of the cell types and label them according to the normal/tumor clusters where they belong.

```{r}
#| label: spatial-clusters-plots

# Count the number of tumor clusters by looking at the column "col_ist_merge_type" and counting the number of unique cluster names that starts with tumor
num_tumor_clusters <- length(grep("^Tumor", unique(breast_cancer_patients_analyze@meta.data[[col_cell_tumor_cluster_subtype]])))
# Create a gray scale for the tumor clusters
tumor_clusters_colors <- gray.colors(12, start = 0.2, end = 0.9)
# Create the color palette for the niches
palette_all_cells_types <- generate_colors_lookup_table(
  breast_cancer_patients_analyze,
  cluster_column_name = col_cell_tumor_cluster_subtype,
  known_clusters_colors = palette_cell_types,
  color_palette = tumor_clusters_colors)
# Create the plots with the cell types for every stamp
cell_types_stamps_plots <- generate_spatial_plots(
  breast_cancer_patients_analyze,
  cluster_var = col_cell_tumor_cluster_subtype,
  cluster_name = "Cell types with tumor subclusters",
  legend_fill = "Cell types",
  color_lookup_table = palette_all_cells_types)
# Display the plots
print(cell_types_stamps_plots)
```

```{r}
#| eval: false

# Save the plots
save_data(cell_types_stamps_plots, file.path(gl_img_dir, "Stamps_with_clusters"))
```

## Spatial niches

### Build niches

```{r}
#| label: build-niches-params

# To build the niche assay, Seurat uses only the spatial images and the cell phenotypes (a column from the metadata)
# Number of niche to calculate
niches_nums <- c(6, 9, 12, 15)
```

```{r}
#| label: build-spatial-niches
#| eval: false

# Build the niche assays
for (num in niches_nums) {
  # Print the current number of niches being calculated
  print(glue("Calculating {num} niches"))
  # Build the niche assay
  breast_cancer_patients_analyze <- BuildNicheAssay(
    object = breast_cancer_patients_analyze,
    fov = "LU001FFP03",
    group.by = col_cell_tumor_cluster_subtype,
    assay = glue("niches{num}"),
    cluster.name = glue("niches_{num}"),
    # Number of niches to find, default is 4
    niches.k = num,
    # Number of neighbors to consider, default is 20
    # Very small neighborhoods produce sparse and noisy data
    # Very large neighborhoods become inaccurate representations of a cell’s 3D surroundings:
    # the area of your circular neighborhood increases with the square of the radius,
    # but the volume of the corresponding (unobserved) 3D tissue 
    # region increases with the cube of the radius.
    # This means that the larger the radius, the less of your 3D neighborhood falls in
    # the narrow tissue slide you’ve assayed, and the more it consists of unseen cells
    # increasingly far away in the Z-dimension.
    neighbors.k = 30
  )
}
```

```{r}
#| eval: false

# Save the object
saveRDS(breast_cancer_patients_analyze, file.path(gl_obj_dir, "breast_cancer_patients_analyze.rds"))
```

### Setup spatial niches study

```{r}
#| label: spatial-niches-study-setup

# Number of niches to plot
niches_plot <- niches_nums[2]
# Metadata column with the niches to plot
col_niches_plot <- glue("niches_{niches_plot}")

# Metadata column with the highest number of niches
col_highest_niches_num <- glue("niches_{niches_nums[length(niches_nums)]}")
# Create the color palette for the niches
niches_color_palette <- generate_colors_lookup_table(
  breast_cancer_patients_analyze,
  cluster_column_name = col_highest_niches_num,
  color_palette = brewer.pal(12, name = "Set3"))
```

### Spatial plots of niches

```{r}
#| label: spatial-niches-plots

# Create the plots with the niches for every stamp
niches_stamps_plots <- generate_spatial_plots(
  breast_cancer_patients_analyze,
  cluster_var = col_niches_plot,
  cluster_name = "Seurat niches",
  legend_fill = "Niches",
  color_lookup_table = niches_color_palette)
# Display the plots
print(niches_stamps_plots)
```

```{r}
#| eval: false

# Save the plots
save_data(niches_stamps_plots, file.path(gl_img_dir, glue("Stamps_with_{niches_plot}_niches")))
```

### Statistics about niches

```{r}
#| label: niches-statistics-calc

# Create list to save data
niches_statistics_calc <- list()

# Count and calculate percentages of cell types inside every niche
# The percentages of the various cells types in a niches adds up to 100%
cell_type_counts <- breast_cancer_patients_analyze@meta.data %>%
  group_by(!!sym(col_niches_plot), !!sym(col_cell_tumor_cluster_subtype)) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count / sum(count)) * 100) %>%
  arrange(.by_group = TRUE)
# Print the cell type counts and percentages
niches_statistics_calc[["cell_type_counts"]] <- cell_type_counts

# Get the list of unique niches
niches <- sort(unique(breast_cancer_patients_analyze@meta.data[[col_niches_plot]]))
# Print the niches
print(sort(niches))

# Create list to save niches data
niches_data <- list()

# Loop through each niche and calculate the data for the plot
for (niche in niches) {
  
  # Set the cutoff value for the percentage
  niche_cell_type_cutoff <- 2
  # Filter out cells in other niches and group the cells types below the cutoff together
  niche_stat <- cell_type_counts %>%
    dplyr::filter(!!sym(col_niches_plot) == niche) %>%
    dplyr::mutate(
      !!sym(col_cell_tumor_cluster_subtype) := ifelse(
        percentage >= niche_cell_type_cutoff,
        !!sym(col_cell_tumor_cluster_subtype),
        "Others")
    ) %>%
    dplyr::group_by(!!sym(col_cell_tumor_cluster_subtype), !!sym(col_niches_plot)) %>%
    dplyr::summarize(
      percentage = sum(percentage, na.rm = TRUE),
      count = sum(count, na.rm = TRUE),
      .groups = "drop"
    )
  niches_data[[glue("Niche_{niche}_statistics")]] <- niche_stat
}
# Add niches data to print list
niches_statistics_calc <- c(niches_statistics_calc, niches_data)

print(niches_statistics_calc)
```

```{r}
#| label: niches-statistics-plots

# Create list to save data
niches_statistics_plots <- list()

# Loop through each niche and create a bar plot
for (niche in niches) {
  
  # Extract niche data
  niche_data <- niches_data[[niche]]

  # Create the bar plot
  niche_barplot <- niche_data %>%
    ggplot(aes(
      x = !!sym(col_cell_tumor_cluster_subtype),
      y = percentage,
      fill = !!sym(col_cell_tumor_cluster_subtype)
    )) +
    geom_bar(stat = "identity") +
    geom_text(
      aes(label = count),
      vjust = -0.3,
      color = "black",
      size = 3.5
    ) +
    labs(
      title = glue("Niche: {niche} of {niches_plot}"),
      subtitle = "Cell Type Distribution",
      caption = glue(
        "Cutoff value: {niche_cell_type_cutoff}%, the cells types with a percentage below the cutoff are grouped together as 'Others'.
        The percentage of each cell type represents its proportion within the niche, with all percentages summing to 100%.
        The count number above the bars represents the number of cells of each type."
      ),
      x = "Cell Type",
      y = "Percentage (%)"
    ) +
    # Make space for the count number above the bars
    expand_limits(y = max(niche_data$percentage) * 1.04) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          # Move caption to the left
          plot.caption = element_text(hjust = 0)) +
    scale_fill_manual(values = palette_all_cells_types) +
    NoLegend()

  # Add the plot to the list
  niches_statistics_plots[[glue::glue("Niche_{niche}_barplot")]] <- niche_barplot
}

# Display all niches bar plots
print(niches_statistics_plots)
```

```{r}
#| label: niches-patients-statistics

# Create list to save data
niches_patient_data <- list()

# Count and calculate percentage of cell types per niche
niches_patient_counts <- breast_cancer_patients_analyze@meta.data %>%
  mutate("{col_niches_plot}" := factor(!!sym(col_niches_plot), levels = sort(unique(!!sym(col_niches_plot)))),
         Patient.ID = factor(Patient.ID)) %>%
  group_by(Patient.ID, !!sym(col_niches_plot)) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count / sum(count)) * 100) %>%
  arrange(Patient.ID, .by_group = TRUE)
# Add to list
niches_patient_data[["niches_patient_counts"]] <- niches_patient_counts

# Create the bar plot
niches_patient_dotplot <- ggplot(niches_patient_counts,
                                 aes(x = Patient.ID, y = percentage, color = !!sym(col_niches_plot))) +
  geom_rect(data = unique(niches_patient_counts["Patient.ID"]),
            aes(xmin = as.numeric(Patient.ID) - 0.4,
                xmax = as.numeric(Patient.ID) + 0.4,
                ymin = -Inf, ymax = Inf),
            fill = "grey90", alpha = 0.3, inherit.aes = FALSE) +
  geom_point(size = 3, position = position_dodge(width = 0.7)) +
  labs(title = paste("Niches distribution across patients"),
       x = "Patient",
       y = "Percentage (%)") +
  guides(color = guide_legend(title = "Niche")) +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1)) +
  scale_color_manual(values = niches_color_palette)
# Add to list
niches_patient_data[["niches_patient_dotplot"]] <- niches_patient_dotplot

# Print the list
print(niches_patient_data)
```

```{r}
#| eval: false

# Folder name
stat_niches_dir <- glue("Statistics_{niches_plot}_niches")
# Save the plots
save_data(niches_statistics_calc, file.path(gl_img_dir, stat_niches_dir))
save_data(niches_statistics_plots, file.path(gl_img_dir, stat_niches_dir))
save_data(niches_patient_data, file.path(gl_img_dir, stat_niches_dir))
```

## CellChat

### Distances

```{r}
#| label: calculate-distances

# Spatial locations of spots from full (NOT high/low) resolution images are required
# Extract the cell coordinates from the Seurat object
spatial_coordinates = Seurat::GetTissueCoordinates(
  object = breast_cancer_patients_analyze,
  image = "LU001FFP03",
) %>%
# Set the rownames equal to the cell names and remove the cell column
  tibble::column_to_rownames(var = "cell")

# Divide the spatial coordinates into the different fovs using the cell names
spatial_coordinates_fovs <- spatial_coordinates %>%
  # Convert rownames to a column for easier manipulation
  mutate(rownames = rownames(.)) %>% 
  separate(rownames, into = c("cell", "fov"), sep = "_") %>%
  group_split(fov)
# Change list names to the fovs names
names(spatial_coordinates_fovs) <- sapply(spatial_coordinates_fovs, function(df) unique(df$fov))

# Create a list of vectors with every core-stamp combination and associated FOVs
core_stamp_to_fovs <- patient_table %>%
  mutate(Core_Stamp = paste(Serial_Cores, Stamps, sep = "_")) %>%
  dplyr::select(Core_Stamp, FOVs) %>%
  group_by(Core_Stamp) %>%
  summarize(FOVs = list(FOVs), .groups = "drop") %>%
  {purrr::set_names(.$FOVs, .$Core_Stamp)}

# Create a new list with the merged fovs spatial locations belonging to the same core-stamp
core_stamp_spatial <- list()
for (core_stamp in names(core_stamp_to_fovs)) {
  core_stamp_spatial[[core_stamp]] <- do.call(rbind, spatial_coordinates_fovs[core_stamp_to_fovs[[core_stamp]]]) %>%
  # Transform the tibbles to dataframes whose rownames are cell_fov 
  mutate(cell_fov = paste(cell, fov, sep = "_")) %>%
  column_to_rownames(var = "cell_fov") %>%
  dplyr::select(-cell, -fov)
}

# Calculate the distances between all the cells inside a single core-stamp
core_stamp_distance_matrix <- list()
for (stamp in names(core_stamp_spatial)) {
core_stamp_distance_matrix[[stamp]] = computeCellDistance(
  coordinates = core_stamp_spatial[[stamp]],
  # to convert the distance from pixels to micrometers
  ratio = cosmx_pixel_to_micron_conversion_factor,
  # In order for the interaction range to take effect, the tolerance should also be specified
  interaction.range = NULL,
  tol = NULL)
}

for (dist_mat in names(core_stamp_distance_matrix)) {

  dist <- core_stamp_distance_matrix[[dist_mat]]
  dat <- as.data.frame(as.matrix(dist))
  value <- stack(dat)$values
  rnames <- rownames(dat)
  namecol <- expand.grid(rnames, rnames)
  colnames(namecol) <- c("cell1", "cell2")
  res <- data.frame(namecol, value)

  # return only lower triangular part of dist
  res <- res[-which(upper.tri(as.matrix(dist), diag = T)), ]
  
  # Extract the metadata dataframe
metadata <- breast_cancer_patients_analyze@meta.data

# Retrieve the column containing cell phenotypes
phenotype_column <- col_cell_tumor_cluster_subtype
cell_to_phenotype <- metadata[[phenotype_column]]  # Extract the relevant column

# Map cell names to phenotypes
cell_to_phenotype_map <- setNames(cell_to_phenotype, rownames(metadata))

# Add the col_cell_type and row_cell_type columns to `res`
res$cell1_type <- cell_to_phenotype_map[res$cell1]
res$cell2_type <- cell_to_phenotype_map[res$cell2]

  return(res)
}

# Extract the metadata dataframe
metadata <- breast_cancer_patients_analyze@meta.data

# Retrieve the column containing cell phenotypes
phenotype_column <- col_ist_merge_type
cell_to_phenotype <- metadata[[phenotype_column]]  # Extract the relevant column

# Map cell names to phenotypes
cell_to_phenotype_map <- setNames(cell_to_phenotype, rownames(metadata))

# Initialize a list to store results
result_list <- list()

# Loop through each distance matrix
for (dist_mat in names(core_stamp_distance_matrix)) {
  
  # Access the current distance matrix
  dist <- core_stamp_distance_matrix[[dist_mat]]
  
  # Convert to data frame
  dat <- as.data.frame(as.matrix(dist))
  value <- stack(dat)$values
  rnames <- rownames(dat)
  namecol <- expand.grid(rnames, rnames)
  colnames(namecol) <- c("cell1", "cell2")
  res <- data.frame(namecol, value)
  
  # Return only lower triangular part of the distance matrix
  res <- res[-which(upper.tri(as.matrix(dist), diag = TRUE)), ]
  
  # Add the cell type information
  res$cell1_type <- cell_to_phenotype_map[res$cell1]
  res$cell2_type <- cell_to_phenotype_map[res$cell2]
  
  # Store the result in the list
  result_list[[dist_mat]] <- res
}

# Combine all results into a single data frame (optional)
final_result <- do.call(rbind, result_list)



# Extract the cell types for the subgroups from the palette
all_cell_types <- c(
  # Brain cells
  "Inhibitory neuron A", "Inhibitory neuron B", "Inhibitory neuron C", 
  "L2/3 neuron", "L4 neuron", "L6 neuron", 
  "Oligodendrocyte-like", "Oligodendrocyte precursor cell", "Oligodendrocyte",
  "Microglia A", "Microglia B", 
  "Astrocyte A", "Astrocyte B",
  
  # Stromal cells
  "Endothelial", "Fibroblast",
  
  # Myeloids
  "Dendritic cell", "Macrophage", "Mast cell", "Monocyte", 
  "Neutrophil", "Plasmacytoid dendritic cell",
  
  # Lymphocytes
  "B cell", "NK cell", "Plasma", "Plasmablast", 
  "T cell CD4", "T cell CD8", "T cell regulatory"
)

# Filter the distance data for pairs involving subgroup cells and tumor cells
filtered_distances <- final_result[
  (final_result$cell1_type %in% all_cell_types & final_result$cell2_type == "Tumor") |
  (final_result$cell2_type %in% all_cell_types & final_result$cell1_type == "Tumor"), 
]

filtered_distances <- filtered_distances %>%
  mutate(
    cell1 = as.character(cell1),
    cell2 = as.character(cell2),
    # Create temporary columns to hold swapped values
    new_cell1 = ifelse(cell1_type == "Tumor", cell2, cell1),
    new_cell2 = ifelse(cell1_type == "Tumor", cell1, cell2),
    new_cell1_type = ifelse(cell1_type == "Tumor", cell2_type, cell1_type),
    new_cell2_type = ifelse(cell1_type == "Tumor", cell1_type, cell2_type)
  ) %>%
  # Assign swapped values back to the original columns
  mutate(
    cell1 = new_cell1,
    cell2 = new_cell2,
    cell1_type = new_cell1_type,
    cell2_type = new_cell2_type
  ) %>%
  # Remove the temporary columns
  dplyr::select(-new_cell1, -new_cell2, -new_cell1_type, -new_cell2_type)

# Find the minimum distance for each cell in the subgroup
closest_distances <- filtered_distances %>%
  group_by(cell1) %>%
  dplyr::filter(value == min(value)) %>%
  ungroup()  # Ungroup the data after filtering

# Print the results
print(closest_distances)

ggplot(closest_distances, aes(x = cell1_type, y = value)) +
  geom_point(aes(color = cell1_type), position = position_jitter(width = 0.2, height = 0), size = 1) +  # Add jitter to avoid overlapping points
  stat_summary(aes(group = cell1_type), fun = mean, geom = "point", color = "red", size = 3) +  # Add points for the average value
  labs(
    title = "Distance from the Closest Tumor Cell by Cell Type",
    x = "Cell Type",
    y = "Distance from closest tumor cell (μm)"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),  # Rotate x-axis labels for readability
        legend.position = "none") +  # Remove the legend
    scale_color_manual(values = palette_cell_types) # Use the custom color palette

# Initialize list to store results
core_stamp_min_max_dist <- list(global = list(max = -Inf, min = Inf))
# Loop through each stamp to compute min and max distances
for (stamp in names(core_stamp_distance_matrix)) {
  current_distances <- core_stamp_distance_matrix[[stamp]]
  core_stamp_min_max_dist[[stamp]] <- list(
    max = max(current_distances, na.rm = TRUE),
    median = median(current_distances, na.rm = TRUE),
    min = min(current_distances, na.rm = TRUE)
  )
  # Update global max and min
  core_stamp_min_max_dist$global$max <- max(core_stamp_min_max_dist$global$max, core_stamp_min_max_dist[[stamp]]$max)
  core_stamp_min_max_dist$global$min <- min(core_stamp_min_max_dist$global$min, core_stamp_min_max_dist[[stamp]]$min)
}
```

### Cell-cell communication

```{r}
#| label: load-cellchat

# Set if using only the RNA data or the spatial data as well
cellchat_datatypes = c("RNA", "spatial")
cellchat_datatype = cellchat_datatypes[2]

# SET THE DATABASE TO BE USED

# The CellChat database contains 4 types of interactions:

### Secreted signaling (Paracrine Signaling):
#   In this type, cells secrete signaling molecules (like growth factors or cytokines) that affect nearby target cells. The molecules diffuse through the extracellular space and bind to receptors on neighboring cells.

### ECM-Receptor signaling:
# This involves interactions between cells and the extracellular matrix (ECM). Cells can bind to ECM components through specific receptors (like integrins), which triggers various cellular responses. These interactions are vital for cell adhesion, migration, and tissue maintenance.

### Cell-Cell contact (Juxtacrine signaling):
#   This involves direct physical contact between cells, where membrane-bound ligands on one cell interact with receptors on an adjacent cell

### Non-protein Signaling:
# This category includes signaling through non-protein molecules such as neurotransmitters, lipids, and other small molecules.

# Ligand-receptor interactions in CellChat database for human
CellChatDB <- CellChatDB.human
# Subset with all CellChatDB interactions except for the "Non-protein Signaling" category
CellChatDB_all_protein_signalling <- subsetDB(CellChatDB, non_protein = FALSE)
# Subset with cell-cell contact interactions
CellChatDB_cell_cell_contact <- subsetDB(CellChatDB, search = "Cell-Cell Contact")
# Subsets with non-contact interactions
CellChatDB_secreted_signaling <- subsetDB(CellChatDB, search = "Secreted Signaling")
CellChatDB_ecm_receptor <- subsetDB(CellChatDB, search = "ECM-Receptor")
# Set the database that should be used
cellchat_databases <- c("all_protein_signalling", "cell_cell_contact", "secreted_signaling", "ecm_receptor")
CellChatDB_suffix <- cellchat_databases[1]
CellChatDB_used <- glue("CellChatDB_{CellChatDB_suffix}")
```

```{r}
#| label: load-cellchat-object

# Load cellchat object
cellchat <- readRDS(file.path(gl_obj_dir, glue("cellchat_{cellchat_datatype}_{CellChatDB_suffix}.rds")))
```

```{r}
#| label: compute-cellchat
#| eval: false

# Create table with clusters size
cluster_sizes <- table(breast_cancer_patients_analyze@meta.data[[col_cell_tumor_cluster_subtype]])
# Extract total number of cells
total_cells <- nrow(breast_cancer_patients_analyze@meta.data)
# Calculate the minimum number of cells for a cluster to be included in the cellchat analysis based on its percentage on the total
cluster_perc = 0.002
min_cells <- ceiling(total_cells * cluster_perc)
# Keep only clusters with at least min_cells
cellchat_clusters_to_analyze <- names(cluster_sizes[cluster_sizes >= min_cells])
# Subset Seurat object to include only large clusters
breast_cancer_patients_cellchat_clusters_to_analyze <- subset(
  breast_cancer_patients_analyze, 
  subset = !!as.name(col_cell_tumor_cluster_subtype) %in% cellchat_clusters_to_analyze
)

# Genes should be in rows with rownames and cells in columns with colnames
# Normalized data (e.g., library-size normalization and then log-transformed with a pseudocount of 1) is required
# The SCT assay should be fine as it is used in the following vignette:
# https://htmlpreview.github.io/?https://github.com/jinworks/CellChat/blob/master/tutorial/CellChat_analysis_of_spatial_transcriptomics_data.html
cell_expression_data = Seurat::GetAssayData(
  breast_cancer_patients_cellchat_clusters_to_analyze,
  layer = "data",
  assay = "SCT")

# Because CosMx does not include the uniform cell size, users can compute the minimum cell centroid-to-centroid distance via computeCellDistance and use its half value as the tolerance factor.
# CellChat does not need an accurate tolerance factor, which is used for determining whether considering the cell-pair as spatially proximal if their distance is greater than interaction.range but smaller than “interaction.range + tol”.
spatial_factors = data.frame(ratio = cosmx_pixel_to_micron_conversion_factor, tol = core_stamp_min_max_dist$global$min / 2)

# Create a new CellChat object from a data matrix
cellchat <- createCellChat(
  # A normalized (NOT count) data matrix (genes by cells)
  object = cell_expression_data,
  # A data frame (rows are cells with rownames) consisting of cell information used for defining cell groups
  meta = breast_cancer_patients_cellchat_clusters_to_analyze@meta.data,
  # A char name of the variable in meta data, defining cell groups
  group.by = col_cell_tumor_cluster_subtype,
  datatype = cellchat_datatype,
  # A data matrix in which each row gives the spatial locations/coordinates of each cell
  coordinates = spatial_coordinates,
  # A data frame containing two distance factors 'ratio' and 'tol', which is dependent on spatial transcriptomics technologies
  spatial.factors = spatial_factors,
  do.sparse = TRUE)

# Set the used database in the object
cellchat@DB <- get(CellChatDB_used)
# Show description of the used database
showDatabaseCategory(cellchat@DB)

# Subset the expression data of signaling genes for saving computation cost
# This step is necessary even if using the whole database
cellchat <- subsetData(cellchat)

# Identify over-expressed signaling genes associated with each cell group
cellchat <- identifyOverExpressedGenes(
  object = cellchat,
  # Only return positive markers
  only.pos = TRUE,
  # whether to return the object
  # otherwise return a data frame consisting of over-expressed signaling genes associated with each cell group
  return.object = TRUE,
  # Threshold of the fraction of cells expressed in one cluster
  thresh.pc = 0,
  # Threshold of the log fold change values
  thresh.fc = 0,
  # Threshold of p-values
  thresh.p = 0.05,
  # the minimum number of expressed cells required for the genes that are considered for cell-cell communication analysis
  min.cells = 8)

# Identify over-expressed ligand-receptor interactions (pairs) within the used CellChatDB
cellchat <- identifyOverExpressedInteractions(
  object = cellchat,
  # Set if it is required that both ligand and receptor from one pair are over-expressed
  variable.both = TRUE,
  # Whether returning a CellChat object
  # If FALSE, it will return a data frame containing the over-expressed ligand-receptor pairs
  return.object = TRUE)

# Use a diffusion process to smooth genes’ expression values based on their neighbors’ defined in a high-confidence experimentally validated protein-protein network
# The smoothed data is also called "projected" because it is generated through a process that predicts or estimates missing or unobserved values in the dataset
# The term "projected" highlights the idea that the smoothed data is not strictly observed but is inferred or extrapolated from the existing raw data, using statistical or computational models
# This projection helps overcome technical limitations like dropout effects in single-cell RNA sequencing, especially when sequencing depth is shallow
# Smoothing the data returns a lot of weak, insignificant interactions. Do not use!
# cellchat <- smoothData(
#   object = cellchat,
#   # Adjacency matrix of protein-protein interaction network to use
#   adj = PPI.human,
#   # Numeric in [0,1] alpha = 0: no smoothing
#   # A larger value alpha results in increasing levels of smoothing
#   alpha = 0.4)

# Compute averaged expression values for each cell group
avg_expr_cell_group <- computeAveExpr(
  object = cellchat,
  # a char vector with the features to use
  features = NULL,
  # methods for computing the average gene expression per cell group
  type = "triMean",
  # the fraction (0 to 0.25) of observations to be trimmed from each end of x before the mean is computed
  trim = 0.22)

# Compute the communication probability/strength between any interacting cell groups
cellchat <- computeCommunProb(
  object = cellchat,
  # Methods for computing the average gene expression per cell group
  type = "triMean",
  # The fraction (0 to 0.25) of observations to be trimmed from each end of x before the mean is computed
  trim = 0.22,
  # Whether use the raw data (i.e., 'object@data.signaling') or the smoothed data (i.e., 'object@data.smooth')
  # Set it to false because of the low sequencing depth of the data being analyzed
  raw.use = TRUE,
  # Whether consider the proportion of cells in each group across all sequenced cells
  # Set it to true as the dataset reflects the natural abundance of different cell types in the sample
  population.size = TRUE,
  # Whether to use distance constraints to compute communication probability
  # Set to true to make communication probability inversely proportional to the computed distance
  distance.use = TRUE,
  # The maximum interaction/diffusion length of ligands (Unit: microns)
  # This hard threshold is used to filter out the connections between spatially distant regions
  # The default is 250 (good as the minum distance between cells on different stamps is 1000)
  interaction.range = 250,
  # The scale.distance ensures that the minimum scaled distance across all pairs of cells is in the range [1, 2]
  # It adjusts spatial distances to be compatible with the algorithm's internal calculations
  # Set the scale distance so that the minumum scaled distance is 1
  scale.distance = 1 / core_stamp_min_max_dist$global$min,
  # The minimum number of interacting cell pairs required for defining spatially proximal cell groups
  k.min = 8,
  # Whether using the 'contact-dependent' manner for inference signaling, that is determining interacting cell pairs by requiring cells to be in direct membrane-membrane contact
  # By default 'contact.dependent = TRUE' when inferring contact-dependent and juxtacrine signaling
  contact.dependent = TRUE,
  # The interaction range (Unit: microns) to restrict the contact-dependent signaling when 'contact.dependent = TRUE'
  # For spatial transcriptomics in a single-cell resolution, 'contact.range' is approximately equal to the estimated cell diameter (i.e., the cell center-to-center distance)
  # Set it to 20 as cancer cells are typically larger than normal human cells (usually around 10 microns)
  # Also chosen by looking at the histogram of the cells height and width
  contact.range = 20,
  # Number of neighbors to restrict the contact-dependent signaling within the neatest neighbors when 'contact.dependent = TRUE'.   # By default, CellChat uses 'contact.range' to restrict the contact-dependent signaling; however, users can also provide a value of 'contact.knn.k', in order to determine interacting cell pairs based on the k-nearest neighbors (knn).
  # Do not use this parameter as contact range is a better option
  contact.knn.k = NULL,
  # Number of bootstrap iterations to perform when calculating statistical significance for communication probabilities
  # Bootstrapping is a resampling method used to estimate the variability of a statistic by repeatedly sampling from the data with replacement
  nboot = 100,
  seed.use = 1L)

# Filter out the cell-cell communication if there are only few cells in certain cell groups
cellchat <- filterCommunication(
  object = cellchat,
  # The minimum number of cells required in each cell group for cell-cell communication
  min.cells = 8,
  # Whether to keep the interactions associated with the rare populations when min.samples >= 2
  rare.keep = TRUE,
  # Whether to keep the non-filtered cell-cell communication in the CellChat object
  # This is useful for avoiding re-running 'computeCommunProb' if you want to adjust the parameters when running 'filterCommunication'.
  nonFilter.keep = TRUE)

# Compute the communication probability on signaling pathway level by summarizing the communication probabilities of all ligands-receptors interactions associated with each signaling pathway
cellchat <- computeCommunProbPathway(
  object = cellchat,
  # Threshold of the p-value for determining significant interaction
  thresh = 0.05)

# Calculate the aggregated cell-cell communication network by counting the number of links or summarizing the communication probability
cellchat <- aggregateNet(
  object = cellchat,
  # Whether removing the isolate cell groups without any interactions when applying subsetCommunication
  remove.isolate = TRUE,
  # Threshold of the p-value for determining significant interaction
  thresh = 0.05)

# Compute the network centrality scores
# the slot 'netP' means the inferred intercellular communication network of signaling pathways
cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = "netP")

# Save cellchat object
saveRDS(cellchat, file.path(gl_obj_dir, glue("cellchat_{cellchat_datatype}_{CellChatDB_suffix}.rds")))
```

### Plot

```{r}
#| label: cellchat-palette

# Create a palette with only the idents used by cellchat otherwise it throws an error
palette_cellchat <- palette_all_cells_types[levels(cellchat@idents)]
# Interactions used
cellchat_interactions <- gsub("_", " ", CellChatDB_suffix)
```

```{r}
#| label: cellchat-plots-all-cells

# Create a list to store plots
plot_list_cellchat <- list()

## Plots of cell-cell communication network

# Plot the number of interactions
# The number of interactions refers to the count of significant ligand-receptor pairs identified between cell populations.
# Circle plot
netVisual_circle(
  net = cellchat@net$count,
  vertex.weight = rowSums(cellchat@net$count),
  weight.scale = TRUE,
  label.edge= FALSE,
  title.name = glue("Number of interactions\n{cellchat_interactions}"),
  margin = 0.2,
  vertex.label.cex = 0.8,
  color.use = palette_cellchat)
plot_list_cellchat[["cellchat_circleplot_count"]] <- recordPlot()
# Heatmap
netVisual_heatmap(
  object = cellchat,
  measure = "count",
  # Darker color for interactions close to 0
  color.heatmap = c("#f0f8ff", "#2166ac"),
  title.name = glue("Number of interactions\n{cellchat_interactions}"),
  font.size = 7,
  color.use = palette_cellchat)
plot_list_cellchat[["cellchat_heatmap_count"]] <- recordPlot()

# Plot the interaction strength
# The interaction strength is calculated as a function of both the expression levels of the signalling molecules (ligands and receptors) and their interaction probability
# Circle plot
netVisual_circle(
  net = cellchat@net$weight,
  vertex.weight = rowSums(cellchat@net$weight),
  weight.scale = TRUE,
  label.edge= FALSE,
  title.name = glue("Interaction strength\n{cellchat_interactions}"),
  color.use = palette_cellchat)
plot_list_cellchat[["cellchat_circleplot_weight"]] <- recordPlot()
# Heatmap
netVisual_heatmap(
  object = cellchat,
  measure = "weight",
  title.name = glue("Interaction strength\n{cellchat_interactions}"),
  font.size = 7,
  color.use = palette_cellchat)
plot_list_cellchat[["cellchat_heatmap_weight"]] <- recordPlot()

# Print signaling pathways showing significant communications
pathways_with_significant_signaling <- cellchat@netP$pathways
print(pathways_with_significant_signaling)

# List to save pathways plots
plot_list_cellchat_pathways <- list()
# Visualize the computed centrality scores using heatmap, allowing ready identification of major signaling roles of cell groups
for (pathway in pathways_with_significant_signaling) {
  par(mfrow = c(1, 1), xpd = TRUE)
  image <- netAnalysis_signalingRole_network(cellchat, signaling = pathway, width = 12, height = 2.5, font.size = 7)
  print(image)
  plot_list_cellchat_pathways[[glue("Signaling_pathway_network_{pathway}")]] <- recordPlot()
}
plot_list_cellchat <- c(plot_list_cellchat, plot_list_cellchat_pathways)

# Show all the significant interactions (L-R pairs) from some cell groups to other cell groups
netVisual_bubble(
  object = cellchat,
  sources.use = NULL,
  targets.use = NULL,
  remove.isolate = TRUE,
  signaling = NULL)
plot_list_cellchat[["cellchat_bubbleplot_interactions"]] <- recordPlot()
```

```{r}
#| label: cellchat-plots-cell-groups

# Examine the signaling sent from each cell group
# Set the parameter edge.weight.max so that edge weights are comparable between different networks
group_size <- as.numeric(table(cellchat@idents))
cellchat_weight_mat <- cellchat@net$weight
# Create a list to store plots
plot_list_cellchat_cell_types <- list()

for (i in 1:nrow(cellchat_weight_mat)) {
  # Cell type being analyzed
  cellchat_cell_group <- rownames(cellchat_weight_mat)[i]
  # Create new matrix with the same dimensions and names as the original, but all elements are initialized to 0
  cellchat_type_weight_mat <- matrix(
    0,
    nrow = nrow(cellchat_weight_mat),
    ncol = ncol(cellchat_weight_mat),
    dimnames = dimnames(cellchat_weight_mat))
  # Fills the i-th row of the new matrix with the corresponding i-th row of the original matrix, all other rows in the new matrix remain zero
  cellchat_type_weight_mat[i, ] <- cellchat_weight_mat[i, ]
  # Visualizes the i-th row of interaction weights
  cellchat_cell_type_circleplot <- netVisual_circle(
    net = cellchat_type_weight_mat,
    # Specify the size of the vertices (nodes) in the network
    vertex.weight = group_size,
    # Scales the edge weights (connection thickness) in the plot
    weight.scale = T,
    # Set the maximum edge weight (thickness) to the largest value in the original matrix
    edge.weight.max = max(cellchat_weight_mat),
    # Add a title to the plot using the name of the i-th row of matrix
    title.name = glue("Interaction strength\n{cellchat_interactions}\n{cellchat_cell_group}"),
    color.use = palette_cellchat)
  print(cellchat_cell_type_circleplot)
  plot_list_cellchat_cell_types[[glue("Cellchat_circleplot_{gsub(' ', '_', rownames(cellchat_weight_mat)[i])}")]] <- recordPlot()
}
```

```{r}
#| label: cellchat-nets-dataframes

# List with data to print
cellchat_dfs <- list()

# Data frame consisting of all the inferred cell-cell communications at the level of ligands/receptors
cellchat_comm_net <- as.tibble(
  subsetCommunication(
    object = cellchat,
    slot.name = "net"))
cellchat_dfs[["cellchat_comm_net"]] <- cellchat_comm_net
# Data frame with the inferred communications at the level of signaling pathways
cellchat_comm_netp <- as.tibble(
  subsetCommunication(
    object = cellchat,
    slot.name = "netP"))
cellchat_dfs[["cell_chat_omm_netp"]] <- cellchat_comm_netp

# Print all the data frames
print(cellchat_dfs)
```

```{r}
#| label: save-cellchat-nets-dataframe
#| eval: false

# Define the saving attributes for the various cellchat plots
cellchat_heatmap_attrs <- list(
  width = 15,
  height = 14,
  units = "cm",
  dpi = 1000
)
cellchat_circleplot_attrs <- list(
  width = 15,
  height = 19,
  units = "cm",
  dpi = 1000
)
cellchat_pathway_network_attrs <- list(
  width = 15,
  height = 8,
  units = "cm",
  dpi = 1000
)
cellchat_bubbleplot_attrs <- list(
  width = 28,
  height = 15,
  units = "cm",
  dpi = 1000
)

# Set the attributes for the main cellchat list
cellchat_images <- file.path(gl_img_dir, "CellChat", cellchat_datatype, CellChatDB_suffix)
plot_list_cellchat <- set_plot_attributes(
  plot_list_cellchat,
  cellchat_heatmap_attrs,
  c("cellchat_heatmap_count", "cellchat_heatmap_weight")
)
plot_list_cellchat <- set_plot_attributes(
  plot_list_cellchat,
  cellchat_circleplot_attrs,
  c("cellchat_circleplot_count", "cellchat_circleplot_weight")
)
plot_list_cellchat <- set_plot_attributes(
  plot_list_cellchat,
  cellchat_pathway_network_attrs,
  names(plot_list_cellchat_pathways)
)
plot_list_cellchat <- set_plot_attributes(
  plot_list_cellchat,
  cellchat_bubbleplot_attrs,
  "cellchat_bubbleplot_interactions"
)
# Save the plots in the main cellchat list
save_data(plot_list_cellchat, cellchat_images)

# Set attributes for the cell types circleplots
cellchat_cell_types_output_dir <- file.path(cellchat_images, "Cell_types")
plot_list_cellchat_cell_types <- set_plot_attributes(
  plot_list_cellchat_cell_types,
  cellchat_circleplot_attrs
)
# Save cell types circleplots
save_data(plot_list_cellchat_cell_types, cellchat_cell_types_output_dir)

# Save dataframes
save_data(cellchat_dfs, cellchat_images)
```