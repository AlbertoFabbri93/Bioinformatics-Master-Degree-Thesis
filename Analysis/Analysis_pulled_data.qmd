---
title: "A study on brain metastases from primary breast cancer"
author: "Alberto Fabbri"
format: html
editor_options: 
  chunk_output_type: inline
---

# Brain metastaes from primary breast cancer

This study aims to investigate the immune microenvironment of brain metastases from primary breast cancer. The analysis is performed on NanoString data from 7 patients.

## Set up the environment

### Packages

This analysis uses `renv` to manage the dependencies. `renv` is a normal R package that can be installed with:

`install.packages("renv")`

Once `renv` is installed it can be used to install the necessary packages by running the following code:

`renv::restore()`

`renv` will then proceed to install all the packages specified in the `renv.lock` file.

**Do not update the version of the packages if not absolutely necessary.**

If some packages have been update, run `renv::snapshot()` to update the `renv.lock` file.

### Quarto

To run this file it is necessary to have `quarto` installed. `quarto` is a software used to create reproducible documents that embed code. It can be installed by downloading it from the official website:

[https://quarto.org]

::: {.content-hidden}
### Load the necessary packages
:::

```{r}
#| label: setup
#| include: false

# Work with single cell and spatial omics data
library("Seurat")

# Do not import these future symbols because they conflict with the zeallot package
library (future, exclude = c("%->%", "%<-%"));
# Parallelize the computation with several worker processes that will run in their own R session
plan("multisession", workers = 6)
# Set the maximum size of the future globals
options(future.globals.maxSize = 6.5 * 2^30)
# Ensure proper random number seeding globally
options(future.seed = TRUE)

###### TIDYVERSE ######
# Data manipulation
library("dplyr")
# Create nice plots
library("ggplot2")
# Open Excel files
library("readxl")
# Open CSV files
library("readr")
# Better dataframes
library("tibble")
# Pivot tibbles
library("tidyr")

# Unpack multiple values without temporary variables
library("zeallot")
# Add interpreted string literals
library("glue")
# Sane way to declare file paths
library("here")
# Machine learning library from NanoString
library("InSituType")
# Used for the barplots
library("dittoSeq")
# Used to visualize the raw images from AtoMx
library("EBImage")
# For faster estimation when using SCTransform
library("glmGamPoi")
# For fast Wilcoxon rank sum test
library("presto")
# Combine multidimensional arrays into a single array
library("abind")
# Sparse and dense matrix classes and methods
library("Matrix")
# Analysis of cell-cell communication
library("CellChat")

## PLOTTING
# Used to annotate images with multiple plots
library("patchwork")
# Used to arrange plots in a common grid
library("ggpubr")
# Extension of ggplot2 supporting relational data structures such as networks, graphs, and trees
library("ggraph")
# Used to plot the cluster tree created by running FindClusters at several resolutions
library("clustree")
# Add more layout options to ggplot
library("ggforce")
# Additional color palettes
library("RColorBrewer")
library("pals")

## GENE SET ENRICHMENT ANALYSIS
# Used to perform gene set enrichment analysis
library("clusterProfiler")
# Database with the gene information
library("org.Hs.eg.db")
# List all supported types
keytypes(org.Hs.eg.db)

# Make every conflict trigger an error
library("conflicted")

# Import custom written functions
source_files_dir <- ("Analysis")
source(here(source_files_dir, "Utils.R"))
source(here(source_files_dir, "Plotting.R"))
source(here(source_files_dir, "Color_palettes.R"))
source(here(source_files_dir, "Reference_profiles.R"))

## DECLARE GLOBAL VARIABLES
# Import environment variables as global variables
# Do not rename these variables as they are declared in Utils.R as well
objects_dir <- Sys.getenv("OBJECTS_DIR")
images_dir <- Sys.getenv("IMAGES_DIR")
images_ext <- Sys.getenv("IMAGES_EXT")
```

## Tidy Seurat object

### Separate assays

The NanoString data is stored in a single assay. The data is divided into three groups: gene expression, negative probes, and system control. The system control and negative probes are not used in the downstream analysis. The gene expression data is moved to a new assay called "RNA". The system control and negative probes are moved to new assays called "SystemControl" and "NegativeProbes", respectively. The metadata is cleaned by removing unnecessary columns and renaming others. The images are copied from the original Seurat object to a new one. The assay name in the images is updated to match the new assay name.

```{r}
#| label: load-cleaned-object

# Load cleaned object from memory
breast_cancer_patients <- readRDS(here(objects_dir, "breast_cancer_patients.rds"))
```

```{r}
#| label: create-clenaed-object
#| eval: false

# Load the original Seurat object
breast_cancer_patients_mixed_features <- readRDS(here(objects_dir, "breast.cancer.patients.original.rds"))

tidy_seurat_object_assay <- function(seurat_object_mixed_features, assay_name) {

  assay <- seurat_object_mixed_features[[assay_name]]
  
  # Extract features for the "Gene", "Negative Probes" and "System Control" assays
  system_control_features <- grep("^SystemControl", rownames(assay), value = TRUE)
  negative_probes_features <- grep("^Negative", rownames(assay), value = TRUE)
  gene_features <- dplyr::setdiff(rownames(assay), c(system_control_features, negative_probes_features))
  
  # Subset the count data for the various groups of features
  system_control_counts <- assay$counts[system_control_features, ]
  negative_probes_counts <- assay$counts[negative_probes_features, ]
  gene_counts <- assay$counts[gene_features, ]
  
  # Create new Assay objects with the respective features
  system_control_assay <- CreateAssay5Object(counts = system_control_counts)
  negative_probes_assay <- CreateAssay5Object(counts = negative_probes_counts)
  gene_assay <- CreateAssay5Object(counts = gene_counts)
  
  # Assay names
  sytem_control_assay_name <- "SystemControl"
  negative_probes_assay_name <- "NegativeProbes"
  gene_assay_name <- "RNA"
  
  # Set appropriate keys for the new assays
  system_control_assay@key <- paste0(sytem_control_assay_name, "_")
  negative_probes_assay@key <- paste0(negative_probes_assay_name, "_")
  gene_assay@key <- paste0(gene_assay_name, "_")
  
  # Create a new Seurat object
  seurat_object_cleaned_features <- CreateSeuratObject(counts = gene_assay)
  seurat_object_cleaned_features[["SystemControl"]] <- system_control_assay
  seurat_object_cleaned_features[["NegativeProbes"]] <- negative_probes_assay
  
  original_metadata <- seurat_object_mixed_features@meta.data
  
  # Specify the metadata columns to exclude
  exclude_cols <- c(
    "orig.ident",
    "nCount_Nanostring",
    "nFeature_Nanostring",
    "nn_b326beb0.2706.4f9e.a165.44afc025b72e_1_cluster_cluster_7a2d0841.7221.45b3.be66.f38ce260c6aa_1",
    "RNA_nbclust_419c19f2.965d.4b31.822e.6eba63b75b54_1_clusters",
    "RNA_nbclust_419c19f2.965d.4b31.822e.6eba63b75b54_1_posterior_probability",
    "cell",
    "nCount_RNA",
    "nFeature_RNA",
    "nCount_negprobes",
    "nFeature_negprobes",
    "Panel",
    "cellSegmentationSetId",
    "cellSegmentationSetName")

  # Remove the specified columns
  filtered_metadata <- original_metadata[, !(colnames(original_metadata) %in% exclude_cols)]
  
  # Rename one metadata column
  colnames(filtered_metadata)[which(colnames(filtered_metadata) == "cell_id")] <- "full_cell_ID"

  # Copy the metadata from the original Seurat object
  seurat_object_cleaned_features <- AddMetaData(object = seurat_object_cleaned_features, metadata = filtered_metadata)
  
  # Copy the images from the original Seurat object
  seurat_object_cleaned_features@images <- seurat_object_mixed_features@images
  # Replace the assay name with the new one
  for (image_key in names(seurat_object_cleaned_features@images)) {
    seurat_object_cleaned_features@images[[image_key]]@assay <- gene_assay_name
  }

  return(seurat_object_cleaned_features)
}

# Separate the assays in the Seurat object
breast_cancer_patients <- tidy_seurat_object_assay(breast_cancer_patients_mixed_features, "Nanostring")

# Save the cleaned object
saveRDS(breast_cancer_patients, here(objects_dir, "breast_cancer_patients.rds"))
```

### Filter out anomalous cells

```{r}
#| label: load-filtered-cells-object

# Load filtered cells object from memory
breast_cancer_patients_filt_cells <- readRDS(here(objects_dir, "breast_cancer_patients_filt_cells.rds"))
```

```{r}
#| label: create-filtered-cells-object
#| eval: false

# Read csv file with cells to remove from Seurat object
cells_to_remove <- read_csv(
  here("Analysis", "metadata", "rbc_filtered_out.csv"),
  col_types = cols("Cell.ID" = "c"))

# Remove the cells from the Seurat object
breast_cancer_patients_filt_cells <- subset(breast_cancer_patients, cells = cells_to_remove$Cell.ID)

# Find cells with extremely low or high number of Features and Counts
cells_to_remove <- WhichCells(breast_cancer_patients_filt_cells, expression = nFeature_RNA < 10 | nCount_RNA > 2500)
# Remove the cells from the Seurat object
breast_cancer_patients_filt_cells <- subset(breast_cancer_patients_filt_cells, cells = cells_to_remove, invert = TRUE)

# Save the filtered cells object
saveRDS(breast_cancer_patients_filt_cells, here(objects_dir, "breast_cancer_patients_filt_cells.rds"))
```

## Quality assurance

```{r}
#| label: qa

# Check if there are mitochondrial genes
mt_gene_count <- sum(grepl("^MT-", rownames(breast_cancer_patients_filt_cells[["RNA"]])))
if (mt_gene_count > 0) {
  cat("TRUE. Number of mitochondrial genes:", mt_gene_count)
} else {
  cat("FALSE. No mitochondrial genes found.")
}
```

## Insitutype Clustering

The clustering performed by Insitutype  uses the raw counts, therefore it is useless to use the integrated data because Seurat does not provide an adjusted count matrix.

```{r}
#| label: ins-metadata-columns

# Name of the column with the raw insitutype clusters
col_ist_raw <- "patients_ist_semisup_clusters"
# Name of the metadata column with the annotated insitutype clusters
col_ist_ann <- "patients_ist_semisup_clusters_ann"
```

### Compute

```{r}
#| label: insitutype-read-from-drive

# Read the Insitutype data from the drive
breast_cancer_patients_analyze <- readRDS(here(objects_dir, "breast_cancer_patients_analyze.rds"))
patients_ist_semisup <- readRDS(here(objects_dir, "patients_ist_semisup.rds"))
```

```{r}
#| label: insitutype-per-patient
#| eval: false

# Create a new Seurat object identical to filt cells
breast_cancer_patients_analyze <- breast_cancer_patients_filt_cells
# Arrays to split
assays_to_split <- c("RNA", "NegativeProbes", "SystemControl")
# Split the arrays
for (assay in assays_to_split) {
  breast_cancer_patients_analyze[[assay]] <- split(
    breast_cancer_patients_analyze[[assay]],
    f = breast_cancer_patients_analyze$Patient.ID)
}
# Set Patient.ID as the identity
Idents(breast_cancer_patients_analyze) <- "Patient.ID"

# Create a list to store the results of the insitutype clustering per patient
patients_ist_semisup <- list()
# Create a list to store the results of the cluster num search function
patients_clusters_num_search_info <- list()
# Set the reference profile
reference_profile <- io_brain_profiles_matrix
# Insitutype clustering - Loop over every patient
for (patient_id in unique(breast_cancer_patients_analyze$Patient.ID)) {

  # Print the patient ID
  print(glue("Analysis of patient {patient_id}"))
  # Compose string of count layer patient
  count_layer_patient <- paste0("counts.", patient_id)
  # Extract the count data for the selected patient
  patient_rna_counts <- LayerData(
    breast_cancer_patients_analyze,
    assay = "RNA",
    layer = count_layer_patient) %>%
  as.matrix() %>%
  t()
  
  # Extract the negative probes for the selected patient
  patient_avg_neg_probes <- LayerData(
    breast_cancer_patients_analyze,
    assay = "NegativeProbes",
    layer = count_layer_patient) %>%
  as.matrix() %>%
  t() %>%
  Matrix::rowMeans()
  
  # Features to be used for the cohorting
  features <- c("Mean.PanCK", "Mean.CD45", "Mean.CD68")
  patient_immunofluorescence <- FetchData(
  object = breast_cancer_patients_analyze, 
  vars = features, # Specify which metadata columns to extract
  cells = WhichCells(breast_cancer_patients_analyze, idents = patient_id)
  )
  
  # Cohort of the patient
  # fastCohorting is stochastic, so set the seed for reproducibility
  set.seed(42);
  # "Gaussian_transform = TRUE" maps variables to gaussians in order to place dramatically different variables on the same scale
  patient_cohort <- fastCohorting(
    patient_immunofluorescence,
    gaussian_transform = TRUE)
  # check clusters and cohort numbers
  table(patient_cohort)
  
  # Set the range to search for the optimal number of extra clusters
  clusts_search_space = 1:8
  set.seed(6)
  # Search the optimal numer of extra clusters
  clusters_num_search_info <- chooseClusterNumber(
    counts = patient_rna_counts,
    neg = patient_avg_neg_probes,
    fixed_profiles = reference_profile,
    n_clusts = clusts_search_space)
  # Save the result to a list
  patients_clusters_num_search_info[[patient_id]] <- clusters_num_search_info
  
  # Get the best number of clusters
  clusts_num <- clusters_num_search_info$best_clust_number
  # Print the best number of clusters
  print(glue("Best number of clusters: {clusts_num}"))
  
  # Semi-supervised learning with insitutype and reference profiles
  # Insitutype needs integers, if given floating point numbers it fails with misleading errors
  patients_ist_semisup[[patient_id]] <- insitutype(
    x = patient_rna_counts,
    neg = patient_avg_neg_probes,
    cohort = patient_cohort,
    
    # Enter your own per-cell background estimates here if you
    # have them; otherwise insitutype will use the negprobes to
    # estimate background for you.
    bg = NULL,
    # Group the cells the do not correspond to any type in the reference matrix
    n_clusts = 1,
    reference_profiles = reference_profile,
    # Update the reference profile based on the current data
    update_reference_profiles = FALSE,
    # choosing inadvisably low numbers to speed the vignette; using the defaults
    # in recommended.
    # This is the number of cells used in each phase, because of random sampling
    n_phase1 = 200,
    n_phase2 = 500,
    n_phase3 = 1000,
    n_starts = 6,
    max_iters = 12
  )
}

# Join Layers
for (assay in assays_to_split) {
  breast_cancer_patients_analyze <- JoinLayers(breast_cancer_patients_analyze, assay = assay, layers = "counts")
}

# Merge patient insitutype clusters
merged_ist_results <- c()
for (i in 1:length(patients_ist_semisup)) {
  merged_ist_results <- c(merged_ist_results, patients_ist_semisup[[i]]$clust)
}
# Add the raw insitutype clusters to the Seurat object
breast_cancer_patients_analyze <- AddMetaData(
  object = breast_cancer_patients_analyze,
  metadata = merged_ist_results,
  col.name = col_ist_raw)
print(get_cluster_info(breast_cancer_patients_analyze, col_ist_raw))

# Rename unknown clusters to tumor
breast_cancer_patients_analyze@meta.data %<>%
  mutate(
    "{col_ist_ann}" := case_match(
      .data[[col_ist_raw]],
      c("a") ~ "Other",
      .default = .data[[col_ist_raw]]
    )
  )
```

### Cell groups

```{r}
#| label: cells-groups

# Define the groups
cell_groups <- list(
  "Myeloids" = c(
    "Macrophage",
    "Mast cell",
    "Monocyte",
    "Neutrophil",
    "Dendritic cell",
    "Plasmacytoid dendritic cell"
  ),
  "Stromal cells" = c(
    "Endothelial",
    "Fibroblast"
  ),
  "Lymphocites" = c(
    "B cell",
    "T cell CD4",
    "T cell CD8",
    "T cell regulatory",
    "NK cell",
    "Plasma",
    "Plasmablast"
  ),
  "Brain cells" = c(
    "Inhibitory neuron A",
    "Inhibitory neuron B",
    "Inhibitory neuron C",
    # Excitatory neurons
    "L2/3 neuron",
    "L4 neuron",
    "L6 neuron",
    # Glial cells
    "Oligodendrocyte-like",
    "Oligodendrocyte precursor cell",
    "Oligodendrocyte",
    # Microglia cells
    "Microglia A",
    "Microglia B",
    # Astrocyte cells
    "Astrocyte A",
    "Astrocyte B"
  )
)

cell_groups_vector <- setNames(rep(names(cell_groups), sapply(cell_groups, length)), unlist(cell_groups))

# Name of the cell type metadata column
col_cell_group <- "cell_type"
# Create the cell type group metadata column
# If a cell type does not belong to any cell group, copy over the cell type
breast_cancer_patients_analyze@meta.data %<>%
  mutate(
    "{col_cell_group}" := ifelse(
      is.na(cell_groups_vector[.data[[col_ist_ann]]]),
      .data[[col_ist_ann]],
      cell_groups_vector[.data[[col_ist_ann]]]
    )
  )
```

### SCTransform

```{r}
#| label: rna-sctransform-calculations
#| eval: false

## SCTransform
# Normalize and scale
breast_cancer_patients_analyze <- SCTransform(
  breast_cancer_patients_analyze,
  do.correct.umi = TRUE,
  return.only.var.genes = FALSE,
  ncells = 6000,
  assay = "RNA",
  new.assay.name = "SCT",
  seed.use = 13,
  verbose = TRUE)
# Run PCA
breast_cancer_patients_analyze <- RunPCA(
  breast_cancer_patients_analyze,
  assay = "SCT",
  reduction.key = "SCTPC_",
  reduction.name = "sct_pca_patients",
  seed.use = 42,
  verbose = TRUE)
# Elbow plot
patients_sct_elbow_plot <- generate_variance_elbow_plots(breast_cancer_patients_analyze, "sct_pca_patients", 50)
print(patients_sct_elbow_plot)
# Run UMAP
breast_cancer_patients_analyze <- RunUMAP(
  breast_cancer_patients_analyze,
  reduction = "sct_pca_patients",
  dims = 1:22,
  reduction.key = "SCTUMAP_",
  reduction.name = "sct_umap_patients",
  seed.use = 42)
```

```{r}
#| label: rna-sctransform-plot

# List to print and save
patients_ist_sct <- list()

# Plot cells by type
patients_ist_type_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_ist_ann,
  reduction = "sct_umap_patients",
  cols = cell_type_colors) +
  labs(title = "Insitutype clusters") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      ncol=1,
      keywidth = unit(0.5, "lines"),
      keyheight = unit(0.8, "lines"),
      spacing = unit(0.2, "lines"))
  ) +
  theme_classic(base_size = 9) &
  NoAxes()
patients_ist_sct[["patients_ist_type_sct_plot"]] <- patients_ist_type_sct_plot

# Plot cells by group
patients_ist_group_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_cell_group,
  reduction = "sct_umap_patients",
  cols = cell_type_colors) +
  labs(title = "Insitutype cell groups") &
  NoAxes()
patients_ist_sct[["patients_ist_group_sct_plot"]] <- patients_ist_group_sct_plot

# Plot patients
patients_sct_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = "Patient.ID",
  reduction = "sct_umap_patients",
  cols = patient_colors) +
  labs(title = "All cells") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      title = "Patient"
    )
  ) &
  NoAxes()
patients_ist_sct[["patients_sct_plot"]] <- patients_sct_plot

Idents(breast_cancer_patients_analyze) <- "neutral"
# Check the quantity and the expression level of genes after normalization
vln_plot_feat_count_sct <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "SCT",
  layer = "data",
  features = c("nFeature_SCT", "nCount_SCT"),
  ncol = 2,
  pt.size = 0
)
# Customize the titles for each plot
vln_plot_feat_count_sct[[1]] <- vln_plot_feat_count_sct[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_sct[[2]] <- vln_plot_feat_count_sct[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_sct <- vln_plot_feat_count_sct + plot_annotation(title = "After SCT normalization")
# Save the plot
patients_ist_sct[["Violin_plot_features_count_sct"]] <- vln_plot_feat_count_sct

# Check the quantity and the expression level of genes per patient after normalization
vln_plot_feat_count_patients_sct <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "SCT",
  layer = "data",
  features = c("nFeature_SCT","nCount_SCT"),
  ncol = 2,
  pt.size = 0,
  group.by = "Patient.ID",
  cols = patient_colors
)
# Customize the titles for each plot
vln_plot_feat_count_patients_sct[[1]] <- vln_plot_feat_count_patients_sct[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_patients_sct[[2]] <- vln_plot_feat_count_patients_sct[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_patients_sct <- vln_plot_feat_count_patients_sct + plot_annotation(title = "After SCT normalization")
# Save the plot
patients_ist_sct[["Violin_plot_patients_features_count_sct"]] <- vln_plot_feat_count_patients_sct

# QC the normalization
feature_plot_feat_count_sct <- FeaturePlot(
  breast_cancer_patients_analyze,
  features = c("nFeature_RNA", "nCount_RNA"),
  reduction = "sct_umap_patients",
  combine = TRUE) + 
  plot_annotation(title = "After SCT normalization")
# Save the plot
patients_ist_sct[["Feature_plot_features_count_sct"]] <- feature_plot_feat_count_sct

# Print
print(patients_ist_sct)
```

### Standard normalization

```{r}
#| label: rna-standard-normalization-calculate
#| eval: false

# Default assay & layer
DefaultAssay(breast_cancer_patients_analyze) <- "RNA"
DefaultLayer(breast_cancer_patients_analyze[["RNA"]]) <- "counts"

# Normalize
breast_cancer_patients_analyze <- NormalizeData(
  breast_cancer_patients_analyze,
  assay = "RNA")
# Scale
breast_cancer_patients_analyze <- ScaleData(
  breast_cancer_patients_analyze,
  assay = "RNA")
# Find variable features
breast_cancer_patients_analyze <- FindVariableFeatures(
  breast_cancer_patients_analyze,
  selection.method = "vst",
  nfeatures = 1000,
  assay = "RNA")
# RunPCA
breast_cancer_patients_analyze <- RunPCA(
  breast_cancer_patients_analyze,
  assay = "RNA",
  reduction.key = "RNAPC_",
  reduction.name = "rna_pca_patients",
  seed.use = 42,
  verbose = TRUE)
# Elbow plot
patients_rna_elbow_plot <- generate_variance_elbow_plots(breast_cancer_patients_analyze, "rna_pca_patients", 50)
print(patients_rna_elbow_plot)
# Run UMAP
breast_cancer_patients_analyze <- RunUMAP(
  breast_cancer_patients_analyze,
  reduction = "rna_pca_patients",
  dims = 1:22,
  reduction.key = "RNAUMAP_",
  reduction.name = "rna_umap_patients",
  seed.use = 42)
```

```{r}
#| label: rna-standard-normalization-plot

# List to print and save
patients_ist_rna <- list()

# Plot cells
patients_ist_type_rna_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = "patients_ist_semisup_clusters_ann",
  reduction = "rna_umap_patients",
  cols = cell_type_colors)
patients_ist_rna[["patients_ist_type_rna_plot"]] <- patients_ist_type_rna_plot
# Plot patients
patients_rna_plot <- DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = "Patient.ID",
  reduction = "rna_umap_patients",
  cols = patient_colors)
patients_ist_rna[["patients_rna_plot"]] <- patients_rna_plot

Idents(breast_cancer_patients_analyze) <- "neutral"
# Check the quantity and the expression level of genes after normalization
vln_plot_feat_count_rna <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "RNA",
  layer = "data",
  features = c("nFeature_RNA", "nCount_RNA"),
  ncol = 2,
  pt.size = 0
)
# Customize the titles for each plot
vln_plot_feat_count_rna[[1]] <- vln_plot_feat_count_rna[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_rna[[2]] <- vln_plot_feat_count_rna[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_rna <- vln_plot_feat_count_rna + plot_annotation(title = "After RNA normalization")
# Save the plot
patients_ist_rna[["Violin_plot_features_count_rna"]] <- vln_plot_feat_count_rna

# Check the quantity and the expression level of genes per patient after normalization
vln_plot_feat_count_patients_rna <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "RNA",
  layer = "data",
  features = c("nFeature_RNA","nCount_RNA"),
  ncol = 2,
  pt.size = 0,
  group.by = "Patient.ID",
  cols = patient_colors
)
# Customize the titles for each plot
vln_plot_feat_count_patients_rna[[1]] <- vln_plot_feat_count_patients_rna[[1]] + labs(subtitle = "Gene count")
vln_plot_feat_count_patients_rna[[2]] <- vln_plot_feat_count_patients_rna[[2]] + labs(subtitle = "Total expression level")
# Add global title
vln_plot_feat_count_patients_rna <- vln_plot_feat_count_patients_rna + plot_annotation(title = "After RNA normalization")
# Save the plot
patients_ist_rna[["Violin_plot_patients_features_count_rna"]] <- vln_plot_feat_count_patients_rna

# QC the normalization
feature_plot_feat_count_rna <- FeaturePlot(
  breast_cancer_patients_analyze,
  features = c("nFeature_RNA", "nCount_RNA"),
  reduction = "rna_umap_patients",
  combine = TRUE) + 
  plot_annotation(title = "After RNA normalization")
# Save the plot
patients_ist_rna[["Feature_plot_features_count_rna"]] <- feature_plot_feat_count_rna

# Print
print(patients_ist_rna)
```

### Plot

```{r}
#| label: insitutype-plot

# Save insitutype data
insitutype_data <- list()

# Generate summary statistics for the Insitutype clusters
insitutype_data[["insitutype_clust_summary_patients"]] <- create_cluster_summary_per_patient(breast_cancer_patients_analyze, col_ist_ann)

# Violin plot with the expression of panCK, CD45 and CD68 for each Insitutype clusters
ist_clust_expr <- VlnPlot(
  breast_cancer_patients_analyze,
  assay = "RNA",
  layer = "data",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  pt.size = 0,
  group.by = col_ist_ann,
  combine = FALSE,
  cols = cell_type_colors
)
ist_clust_expr <- lapply(ist_clust_expr, function(x) x &NoLegend())
insitutype_data <- c(insitutype_data, ist_clust_expr)

# Calculate the mean of CD45, CD68 and PanCK for each Insitutype cluster
ist_ann_cluster_statistics <- breast_cancer_patients_analyze@meta.data %>%
  group_by(!!sym(col_ist_ann)) %>%
  summarise(
    `Mean PanCK` = mean(Mean.PanCK),
    `Mean CD45` = mean(Mean.CD45),
    `Mean CD68` = mean(Mean.CD68),
    .groups = "drop"
  )
insitutype_data[["ist_ann_cluster_statistics"]] <- ist_ann_cluster_statistics

print(insitutype_data)
```

```{r}
#| label: insitutype-save-data
#| eval: false

# Save the Insitutype plots
save_data(patients_ist_sct, here(images_dir, "Insitutype"))
save_data(patients_ist_rna, here(images_dir, "Insitutype"))
save_data(insitutype_data, here(images_dir, "Insitutype"))
```

```{r}
#| label: insitutype-save-rds
#| eval: false

# Save insitutype list
saveRDS(patients_ist_semisup, here(objects_dir, "patients_ist_semisup.rds"))
# Save Seurat object
saveRDS(breast_cancer_patients_analyze, here(objects_dir, "breast_cancer_patients_analyze.rds"))
```

## Split

Create two separate Seurat objects for tumor and normal cells using the Insitutype clusters

```{r}
#| label: insitutype-add-metadata

# Add insitutype annotated clusters to filt cells object
breast_cancer_patients_filt_cells <- AddMetaData(
  object = breast_cancer_patients_filt_cells,
  metadata = FetchData(
    object = breast_cancer_patients_analyze,
    vars = col_ist_ann),
  col.name = col_ist_ann
)
# Add insitutype group clusters to filt cells object
breast_cancer_patients_filt_cells <- AddMetaData(
  object = breast_cancer_patients_filt_cells,
  metadata = FetchData(
    object = breast_cancer_patients_analyze,
    vars = col_cell_group),
  col.name = col_cell_group
)
```

```{r}
#| label: insitutype-split
#| eval: false
# Extract the Insitutype clusters metadata column
ist_ann_column <- FetchData(
  object = breast_cancer_patients_filt_cells,
  vars = col_ist_ann)
# Create Seurat objects with the non-cancerous cells
breast_cancer_patients_normal_cells <- 
  breast_cancer_patients_filt_cells[, which(x = ist_ann_column != "Tumor")]
# Create Seurat objects with the cancerous cells
breast_cancer_patients_tumor_cells <-
  breast_cancer_patients_filt_cells[, which(x = ist_ann_column == "Tumor")]
```

## Normal cells

### Compute

```{r}
#| label: normal-cells-read-from-drive

# Load normal cells object from memory
breast_cancer_patients_normal_cells <- readRDS(here(objects_dir, "breast_cancer_patients_normal_cells.rds"))
```

```{r}
#| label: normal-cells-computation
#| eval: false

# Run SCTransform
breast_cancer_patients_normal_cells <- SCTransform(
  breast_cancer_patients_normal_cells,
  do.correct.umi = TRUE,
  return.only.var.genes = FALSE,
  assay = "RNA",
  new.assay.name = "SCT",
  seed.use = 13,
  verbose = TRUE)
# Run PCA
breast_cancer_patients_normal_cells <- RunPCA(
  breast_cancer_patients_normal_cells,
  assay = "SCT",
  reduction.key = "SCTPC_",
  reduction.name = "sct_pca_normal_cells",
  seed.use = 42,
  verbose = TRUE)
# Generate variance elbow plots
generate_variance_elbow_plots(breast_cancer_patients_normal_cells, "sct_pca_normal_cells", 50)
# Run UMAP
breast_cancer_patients_normal_cells <- RunUMAP(
  breast_cancer_patients_normal_cells,
  reduction = "sct_pca_normal_cells",
  dims = 1:30,
  reduction.key = "SCTUMAP_",
  reduction.name = "sct_umap_normal_cells",
  seed.use = 42)
```

### Plot

```{r}
#| label: normal-cells-plot

# Create empty list to store normal cells images
normal_cells_images <- list()

# Calculate the statistics for the normal cells
normal_cells_cluster_statistics <- breast_cancer_patients_normal_cells@meta.data %>%
  # Group by patient and cluster, then calculate percentage
  group_by(Patient.ID, !!sym(col_ist_ann), !!sym(col_cell_group)) %>%
  summarise(count = n(), .groups = "drop") %>%
  group_by(Patient.ID) %>%
  mutate(Percentage = count / sum(count) * 100) %>%
  ungroup() %>%
  # Ensure Patient.ID is a factor
  mutate(Patient.ID = as.factor(Patient.ID)) %>%
  # Calculate mean and sd for each cluster
  group_by(!!sym(col_ist_ann)) %>%
  mutate(
    MeanPercentage = mean(Percentage),
    SDPercentage = sd(Percentage)
  ) %>%
  ungroup()
normal_cells_images[["normal_cells_cluster_statistics"]] <- normal_cells_cluster_statistics

# Plot the percentages of the various types of cells (except cancer cells)
normal_cells_cluster_distribution_barplot <- normal_cells_cluster_statistics %>%
  # Plot the data in a grouped barplot
  ggplot(aes(x = !!sym(col_ist_ann), y = Percentage, fill = Patient.ID)) +
  geom_bar(stat = "identity", position = position_dodge2(preserve = "single", padding = 0), width = .8) +
  facet_grid(cols = ggplot2::vars(!!sym(col_cell_group)), scales = "free_x", space = "free") +
  theme_minimal() +
  labs(x = NULL, 
       y = "Percentage of Cells", 
       title = "Normal Cells Types Distribution by Patient",
       fill = "Patient") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        panel.spacing = unit(0.8, "lines")) +
  scale_fill_manual(values = patient_colors)
normal_cells_images[["normal_cells_cluster_distribution_barplot"]] <- normal_cells_cluster_distribution_barplot

# Plot the distribution of normal cell clusters by patient
normal_cells_cluster_distribution_dotplot <- normal_cells_cluster_statistics %>%
  # Plot the data
  ggplot(aes(x = Percentage, y = !!sym(col_ist_ann))) +
  # Add dots for each patient
  geom_point(aes(color = Patient.ID), size = 3, alpha = 0.7) +
  # Add mean percentage point
  stat_summary(aes(shape = "Mean"), fun = mean, geom = "point", size = 5, color = "black", alpha = 0.7) +
  # Add standard deviation error bars
  geom_errorbarh(aes(xmin = MeanPercentage - SDPercentage, 
                     xmax = MeanPercentage + SDPercentage, 
                     y = !!sym(col_ist_ann),
                     linetype = "Standard Deviation"), 
                 color = "black", alpha = 0.7, height = 0.5, size = 0.2) +
  theme_minimal() +
  ggforce::facet_col(
    facets = col_cell_group,
    scales = "free_y",
    space = "free",
    drop = TRUE,
    strip.position = "top"
  ) +
  labs(x = "Percentage of Cells", y = NULL,
       title = "Normal Cells Types Distribution by Patient",
       color = "Patient") +
  scale_color_manual(values = patient_colors) +
  scale_shape_manual(values = c("Mean" = 18), labels = c("Mean")) +
  scale_linetype_manual(values = c("Standard Deviation" = "solid"), labels = c("Standard Deviation")) +
  guides(
    color = guide_legend(order = 1),
    shape = guide_legend(order = 2, title = "Statistics"),
    linetype = guide_legend(order = 3, title = "Statistics")
  )
normal_cells_images[["normal_cells_cluster_distribution_dotplot"]] <- normal_cells_cluster_distribution_dotplot

# Umap normal cells groups
normal_cells_patients_umap_plot <- DimPlot(
  object = breast_cancer_patients_normal_cells,
  group.by = "Patient.ID",
  reduction = "sct_umap_normal_cells"
  )  +
  labs(title = "Normal cells") +
  guides(
    color = guide_legend(
      title = "Patient",
      override.aes = list(size=2)
    )
  ) &
  NoAxes()
normal_cells_images[["normal_cells_patients_umap_plot"]] <- normal_cells_patients_umap_plot

# Umap normal cells types
normal_cells_type_umap_plot <- DimPlot(
  object = breast_cancer_patients_normal_cells,
  group.by = col_ist_ann,
  reduction = "sct_umap_normal_cells",
  cols = cell_type_colors
  )  +
  labs(title = "Normal cells clusters") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      ncol=1,
      keywidth = unit(0.5, "lines"),
      keyheight = unit(0.8, "lines"),
      spacing = unit(0.2, "lines"))
  ) +
  theme_classic(base_size = 9) &
  NoAxes()
normal_cells_images[["normal_cells_type_umap_plot"]] <- normal_cells_type_umap_plot

# Umap normal cells groups
normal_cells_group_umap_plot <- DimPlot(
  object = breast_cancer_patients_normal_cells,
  group.by = col_cell_group,
  reduction = "sct_umap_normal_cells"
  )  +
  labs(title = "Normal cells groups") &
  NoAxes()
normal_cells_images[["normal_cells_group_umap_plot"]] <- normal_cells_group_umap_plot

print(normal_cells_images)
```

```{r}
#| label: normal-cells-save-plots
#| eval: false

# Save the normal cells plots
save_data(normal_cells_images, here(images_dir, "Normal cells"))
```

```{r}
#| label: normal-cells-save-rds
#| eval: false

# Save the Seurat object
saveRDS(breast_cancer_patients_normal_cells, here(objects_dir, "breast_cancer_patients_normal_cells.rds"))
```

## Cancerous cells

### Cluster

```{r}
#| label: tumor-cells-read-from-drive

# Load tumor cells object from memory
breast_cancer_patients_tumor_cells <- readRDS(here(objects_dir, "breast_cancer_patients_tumor_cells.rds"))
```

```{r}
#| label: tumor-cells-metadata-columns

# Name of the metadata column with the tumor clusters
tumor_cluster_name <- "louvain_tumor_cells_clusters"
# Find clusters of tumor cells
# The default resolution is 1, increase it to get more clusters or decrease it to get fewer clusters
# Try a range of resolutions
seq_res <- seq(0.1, 0.4, by = 0.1)
# Create custom cluster names based on the actual resolution values
tumor_cluster_seq_res <- glue::glue("{tumor_cluster_name}.{seq_res}")
```

```{r}
#| label: tumor-cells-compute
#| eval: false

# After subsetting a Seurat object it is good to normalize it again
breast_cancer_patients_tumor_cells <- SCTransform(
  breast_cancer_patients_tumor_cells,
  return.only.var.genes = FALSE,
  assay = "RNA",
  new.assay.name = "SCTtumors",
  verbose = TRUE)

# Run PCA
breast_cancer_patients_tumor_cells <- RunPCA(
  breast_cancer_patients_tumor_cells,
  reduction.key = "TCPC_",
  reduction.name = "pca_tumor_cells",
  seed.use = 42,
  verbose = TRUE)
# Generate variance elbow plots
generate_variance_elbow_plots(breast_cancer_patients_tumor_cells, "pca_tumor_cells", 50)
# Dimension to use for subsequent analysis, decided lokking at the elbow plot
tumor_cells_dims <- 1:23
# Find neighbors of tumor cells
# Number of PCA dimensions used in Seurat's FindNeighbors function
#
# Using MORE dimensions:
# Captures more subtle biological variation
# Includes more complex relationships between genes
# May include more noise/technical artifacts
# Computationally more intensive
#
# Using FEWER dimensions:
# Focuses on major sources of variation
# More robust to technical noise
# May miss subtle biological signals
# Computationally faster
breast_cancer_patients_tumor_cells <- FindNeighbors(
  breast_cancer_patients_tumor_cells,
  reduction = "pca_tumor_cells",
  dims = tumor_cells_dims,
  verbose = TRUE)

# Find clusters at different resolutions
breast_cancer_patients_tumor_cells <- FindClusters(
  breast_cancer_patients_tumor_cells,
  resolution = seq_res,
  cluster.name = tumor_cluster_seq_res,
  random.seed = 5,
  verbose = TRUE)

# Run UMAP
breast_cancer_patients_tumor_cells <- RunUMAP(
  breast_cancer_patients_tumor_cells,
  reduction = "pca_tumor_cells",
  reduction.key = "TCUMAP_",
  reduction.name = "umap_tumor_cells",
  dims = tumor_cells_dims,
  verbose = TRUE,
  seed.use = 42)
```

### Plot

```{r}
#| label: tumor-cells-plot

tumor_plots_to_save <- list()

# View UMAP with tumor cells at different clustering resolutions
tumor_cells_different_resolutions <- DimPlot(
  breast_cancer_patients_tumor_cells,
  reduction="umap_tumor_cells",
  ncol=2,
  group.by=tumor_cluster_seq_res,
  label=TRUE,
  ) & 
  NoLegend() & 
  NoAxes() & 
  theme(
  plot.margin = unit(c(0, 0, 0, 0), "lines"),
  plot.title = element_text(size = 12, face = "bold")
  )
tumor_plots_to_save[["tumor_cells_different_resolutions"]] <- tumor_cells_different_resolutions

# View UMAP with tumor cells and patient clusters
tumor_cells_patient_id_plot <- DimPlot(
  breast_cancer_patients_tumor_cells,
  reduction = "umap_tumor_cells",
  label = TRUE,
  label.box=TRUE,
  group.by = "Patient.ID",
  cols = patient_colors) +
  labs(title = "Patient ID clusters") &
  NoLegend() &
  NoAxes()
tumor_plots_to_save[["tumor_cells_patient_id_plot"]] <- tumor_cells_patient_id_plot

# Chosen resolution
chosen_tumor_cluster_resolution <- 0.2
# Chosen cluster
chosen_tumor_cluster <- glue::glue("{tumor_cluster_name}.{chosen_tumor_cluster_resolution}")
# Set identity to tumor clusters
Idents(breast_cancer_patients_tumor_cells) <- chosen_tumor_cluster

# Generate DimPlot of chosen resolution
tumor_cells_chosen_resolution_plot <- DimPlot(
  breast_cancer_patients_tumor_cells,
  reduction = "umap_tumor_cells",
  group.by = chosen_tumor_cluster,
  label = TRUE) +
  labs(title = "Tumor Cell Clusters") &
  NoLegend() &
  NoAxes()
# Print DimPlots side by side
tumor_clusters_patient_clusters <- tumor_cells_patient_id_plot + tumor_cells_chosen_resolution_plot
tumor_plots_to_save[["tumor_clusters_patient_clusters"]] <- tumor_clusters_patient_clusters

# Generate FeaturePlot of tumor clusters
# max.cutoff q95 is set so any values above the 95th percentile will be set to the 95th percentile value,
# this helps prevent extreme outliers from dominating the color scale
# min.cutoff 0 is set so any positive value will be highlighted
tumor_cells_feature_plot <- (FeaturePlot(
  object = breast_cancer_patients_tumor_cells,
  reduction = "umap_tumor_cells",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  max.cutoff = "q95",
  min.cutoff = 0,
  label = TRUE) &
  NoAxes()) +
  plot_annotation(title = "Tumor Cells")
tumor_plots_to_save[["tumor_cells_feature_plot"]] <- tumor_cells_feature_plot

# Calculate statistics for the tumor clusters
tumor_cells_cluster_statistics <- breast_cancer_patients_tumor_cells@meta.data %>%
  dplyr::rename(`Tumor cluster` = !!sym(chosen_tumor_cluster)) %>%
  # Group by patient and cluster, then calculate percentage
  group_by(Patient.ID, `Tumor cluster`) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Patient.ID) %>%
  mutate(Percentage = Count / sum(Count) * 100) %>%
  ungroup() %>%
  # Ensure Patient.ID is a factor
  mutate(Patient.ID = as.factor(Patient.ID))

# Print tibble with the percentages of cells in each cluster per patient
tumor_cells_percent_clust_patient <- tumor_cells_cluster_statistics %>%
  # Specify id_cols so the Count column is dropped
  pivot_wider(names_from = Patient.ID, values_from = Percentage, id_cols = `Tumor cluster`) %>%
  # Round the values to two decimal places
  mutate(across(2:8, round, 2)) %>%
  # Sort according to the Tumor cluster column
  arrange(`Tumor cluster`)
tumor_plots_to_save[["tumor_cells_percent_clust_patient"]] <- tumor_cells_percent_clust_patient

# Print tibble with the count of cells in each cluster per patient
tumor_cells_count_clust_patient <- tumor_cells_cluster_statistics %>%
  # Specify id_cols so the Percentage column is dropped
  pivot_wider(names_from = Patient.ID, values_from = Count, id_cols = `Tumor cluster`) %>%
  # Replace NA values with 0 so that the total cells per cluster can be calculated
  mutate(across(2:8, ~replace_na(.x, 0))) %>%
  group_by(`Tumor cluster`) %>%
  mutate(`Tot. clust. cells` = sum(across(where(is.numeric)))) %>%
  ungroup() %>%
  arrange(`Tumor cluster`)
tumor_plots_to_save[["tumor_cells_count_clust_patient"]] <- tumor_cells_count_clust_patient

# Plot the distribution of tumor cell clusters by patient
tumor_cells_cluster_distribution_plot <- tumor_cells_cluster_statistics %>%
  # Plot the data
  ggplot(aes(x = Percentage, y = `Tumor cluster`)) +
  # Add dots for each patient
  geom_point(aes(color = Patient.ID), size = 3, alpha = 0.7) +
  theme_minimal() +
  labs(x = "Percentage of Cells", y = "Tumor Cluster", 
       title = "Tumor Cell Clusters Distribution by Patient",
       color = "Patient") +
  theme(legend.position = "right") +
  scale_color_brewer(palette = "Set1") +
  guides(
    color = guide_legend(order = 1),
  )
tumor_plots_to_save[["tumor_cells_cluster_distribution_plot"]] <- tumor_cells_cluster_distribution_plot

# Identify genes in the SCTtumors assay that start with "KRT"
# These should be the genes that contributes the most to the gene expression
# measured by the antibody panCK
krt_genes <- grep("^KRT", rownames(breast_cancer_patients_tumor_cells[["SCTtumors"]]), value = TRUE)
# Calculate the average expression of the KRT genes for each cell
krt_avg_expression <- Matrix::colMeans(
  breast_cancer_patients_tumor_cells[["SCTtumors"]]@data[krt_genes, ])
# Add the average expression as a new metadata column
breast_cancer_patients_tumor_cells$KRT_Avg_Expression <- krt_avg_expression

# Visualize the co-expression of the KRT genes and the panCK antibody
KRT_panCK_coexpression <- (FeaturePlot(
  breast_cancer_patients_tumor_cells,
  reduction = "umap_tumor_cells",
  max.cutoff = "q95",
  min.cutoff = 0,
  features = c("Mean.PanCK", "KRT_Avg_Expression"),
  blend = TRUE
)  & NoAxes()) + 
  plot_layout(ncol = 2) +
  theme(plot.title = element_text(hjust = 0.5))
KRT_panCK_coexpression[[1]] <-
  KRT_panCK_coexpression[[1]] + 
  labs(title = "PanCK", subtitle = "Mean expression")
KRT_panCK_coexpression[[2]] <-
  KRT_panCK_coexpression[[2]] + 
  labs(title = "KRT genes", subtitle = "Mean expression")
KRT_panCK_coexpression[[3]] <-
  KRT_panCK_coexpression[[3]] + 
  labs(title = "PanCK & KRT genes", subtitle = "Co-expression")
tumor_plots_to_save[["KRT_panCK_coexpression"]] <- KRT_panCK_coexpression

# Violin plot with the expression of panCK, CD45 and CD68 for each Insitutype clusters
tumor_clust_protein_expr <- VlnPlot(
  breast_cancer_patients_tumor_cells,
  assay = "SCTtumors",
  layer = "data",
  features = c("Mean.PanCK", "Mean.CD45", "Mean.CD68"),
  pt.size = 0,
  group.by = chosen_tumor_cluster,
  combine = FALSE
)
tumor_clust_protein_expr <- lapply(
  tumor_clust_protein_expr,
  function(x) x & NoLegend() & labs(subtitle = "Tumor Clusters"))
names(tumor_clust_protein_expr) <- c("PanCK", "CD45", "CD68")
tumor_plots_to_save <- c(tumor_plots_to_save, tumor_clust_protein_expr)

# Calculate the mean of CD45, CD68 and PanCK for each Insitutype cluster
tumor_cluster_statistics <- breast_cancer_patients_tumor_cells@meta.data %>%
  group_by(!!sym(chosen_tumor_cluster)) %>%
  summarise(
    `Mean PanCK` = mean(Mean.PanCK),
    `Mean CD45` = mean(Mean.CD45),
    `Mean CD68` = mean(Mean.CD68),
    .groups = "drop"
  ) %>%
  arrange(desc(`Mean PanCK`))
tumor_plots_to_save[["tumor_cluster_statistics"]] <- tumor_cluster_statistics

print(tumor_plots_to_save)
```

```{r}
#| label: tumor-cells-save-plots
#| eval: false

# Save the tumor cells plots
save_data(tumor_plots_to_save, here(images_dir, "Tumor clusters"))
```

```{r}
#| label: tumor-cells-save-rds
#| eval: false

# Save the Seurat object
saveRDS(breast_cancer_patients_tumor_cells, here(objects_dir, "breast_cancer_patients_tumor_cells.rds"))
```

### Markers

```{r}
#| label: tumor-cells-markers-read-from-drive

# Load tumor cells object from memory
tumor_markers_data <- readRDS(here(objects_dir, "tumor_markers_data.rds"))

```


```{r}
#| label: tumor-cells-markers-computation
#| eval: false

# Find all markers of the tumor clusters
# GSEA needs both positive and negative markers
tumor_markers_data <- FindAllMarkers(
  breast_cancer_patients_tumor_cells,
  test.use = "wilcox",
  assay = "SCTtumors",
  only.pos = FALSE,
  random.seed = 5)

# Save the data
saveRDS(tumor_markers_data, here(objects_dir, "tumor_markers_data.rds"))
```


```{r}
#| label: tumor-cells-markers-plots

# List with data to save
tumor_markers_to_print <- list()

# Filter markers to get the most significant up-regulated ones per cluster
most_significant_tumor_markers <- tumor_markers_data %>%
  group_by(cluster) %>%
  dplyr::filter(avg_log2FC > 1) %>%
  slice_head(n = 10) %>%
  ungroup()
tumor_markers_to_print[["most_significant_tumor_markers"]] <- most_significant_tumor_markers

tumor_clust_diff_expr_genes_heatmap <- DoHeatmap(
    breast_cancer_patients_tumor_cells,
    features = most_significant_tumor_markers$gene,
    assay = "SCTtumors",
    label = TRUE,
    size = 2
    #group.colors = color_lookup_table,
   ) + theme(
     axis.text.y = element_text(size = 5),
   ) + labs(
     title = paste("Tumor clusters"),
     subtitle = "Top 10 Differentially Expressed Genes per Cluster"
   )
tumor_markers_to_print[["tumor_clust_diff_expr_genes_heatmap"]] <- tumor_clust_diff_expr_genes_heatmap

print(tumor_markers_to_print)
```
```{r}
library(ComplexHeatmap)
library(circlize)

# Prepare the expression matrix
# Extract the expression data for the selected genes
expr_matrix <- as.matrix(GetAssayData(breast_cancer_patients_tumor_cells, 
                                       slot = "data", 
                                       assay = "SCTtumors")[
                                         most_significant_tumor_markers$gene, 
                                       ])

# Prepare cell type annotations
cell_types <- Idents(breast_cancer_patients_tumor_cells)
cell_type_df <- data.frame(cell_type = cell_types)
rownames(cell_type_df) <- colnames(expr_matrix)

# Create color palette for cell types
unique_cell_types <- unique(cell_types)
cell_type_colors <- setNames(
  rainbow(length(unique_cell_types)),
  unique_cell_types
)

png(here("test.png"),width=3.25,height=3.25,units="in",res=1200)

# Create the heatmap
tumor_clust_diff_expr_genes_heatmap <- Heatmap(
  matrix = expr_matrix,
  name = "Expression",
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_column_names = FALSE,
  show_row_names = TRUE,
  row_names_gp = gpar(fontsize = 5),
  column_split = cell_types,
  column_title = "Tumor clusters: Top 10 Differentially Expressed Genes per Cluster",
  top_annotation = HeatmapAnnotation(
    cell_type = cell_types,
    col = list(cell_type = cell_type_colors),
    show_legend = TRUE
  ),
  # Color scale for expression
  col = colorRamp2(
    c(min(expr_matrix), median(expr_matrix), max(expr_matrix)), 
    c("blue", "white", "red")
  )
)

dev.off()

print(tumor_clust_diff_expr_genes_heatmap)
```

```{r}
#| label: annotate-other-cells

# Name of the other cell annotated column
col_other_cells_ann <- "other_clusters_ann"
col_tumor_cells_ann <- "tumor_clusters_ann"
col_ist_merge <- "cell_final_type"

# Create metadata column distinguishing between tumor and other cells
breast_cancer_patients_tumor_cells@meta.data %<>%
  mutate("{col_other_cells_ann}" := case_match(
  breast_cancer_patients_tumor_cells$seurat_clusters,
  "7" ~ "Unknown",
  .default = "Tumor",
))

# Create a metadata column with all the tumor subclusters
breast_cancer_patients_tumor_cells@meta.data %<>%
  mutate("{col_tumor_cells_ann}" := case_match(
  breast_cancer_patients_tumor_cells$seurat_clusters,
  "7" ~ "Unknown",
  .default = glue("Tumor {get(chosen_tumor_cluster)}"),
))

# Add other cells clusters to analyze object
breast_cancer_patients_analyze <- AddMetaData(
  object = breast_cancer_patients_analyze,
  metadata = FetchData(
    object = breast_cancer_patients_tumor_cells,
    vars = col_other_cells_ann),
  col.name = col_other_cells_ann
)

# Merge the other cells clusters with the insitutype clusters
breast_cancer_patients_analyze@meta.data %<>%
mutate("{col_ist_merge}" := if_else(
    get(col_ist_ann) != "Other",
    get(col_ist_ann),
    get(col_other_cells_ann)
))

DimPlot(
  object = breast_cancer_patients_analyze,
  group.by = col_ist_merge,
  reduction = "sct_umap_patients",
  cols = cell_type_colors) +
  labs(title = "Insitutype clusters") +
  guides(
    color = guide_legend(
      override.aes = list(size=2),
      ncol=1,
      keywidth = unit(0.5, "lines"),
      keyheight = unit(0.8, "lines"),
      spacing = unit(0.2, "lines"))
  ) +
  theme_classic(base_size = 9) &
  NoAxes()
```

```{r}
#| label: tumor-markers-save
#| eval: false

# Save the data
save_data(tumor_markers_to_print, here(images_dir, "Tumor markers"))
```

## Gene Set Enrichment Analysis

### GSEA objects

```{r}
#| label: gsea-load-objects

# Load the GSEA results
GSEA_results <- readRDS(here(objects_dir, "GSEA_results.rds"))
```

```{r}
#| label: gsea-create-objects
#| eval: false

# Set default assay to RNA
DefaultAssay(breast_cancer_patients_tumor_cells) <- "RNA"

# Set the colors for the p adjust gradient bar
max_color <- rgb(238, 197, 194, maxColorValue = 255)
min_color <- rgb(215, 102, 86, maxColorValue = 255)
options(enrichplot.colours = c(min_color, max_color))

# List to save the GSEA results
GSEA_results <- list()
# Run GSEA for each tumor cluster
for (cluster in levels(breast_cancer_patients_tumor_cells)) {
  tumor_cluster_number <- cluster
  print(paste("Running GSEA analysis for cluster:", tumor_cluster_number))
  
  # Get the markers for the tumor cluster
  tumor_cluster_markers <- tumor_markers_data %>%
    dplyr::filter(cluster == tumor_cluster_number)
  
  # How to create the gene list
  # http://yulab-smu.top/biomedical-knowledge-mining-book/faq.html#genelist
  # Gene list creation
  gsea_gene_list <- tumor_cluster_markers %>%
    dplyr::mutate(rank = rank(avg_log2FC, ties.method = "random")) %>%
    dplyr::arrange(desc(rank)) %>%
    with(setNames(avg_log2FC, gene))
  
  # Run GSEA
  gsea <- gseGO(geneList     = gsea_gene_list,
                    keyType      = "SYMBOL",
                    OrgDb        = org.Hs.eg.db, 
                    ont          = "BP",
                    minGSSize    = 10,
                    maxGSSize    = 500,
                    pvalueCutoff = 0.05,
                    verbose      = TRUE,
                    pAdjustMethod = "fdr")
  # Save the GSEA results
  GSEA_results[[tumor_cluster_number]] <- gsea
}

# Save the GSEA results
saveRDS(GSEA_results, here(objects_dir, "GSEA_results.rds"))
```

### GSEA plots

```{r}
#| message: false
#| warning: false
#| fig-width: 9
#| fig-height: 6
# Disable messages and warnings so they do not appear above the first image generated by the loop
# Make images bigger so they are easier to read

# Create a list of gene counts for each cluster
cluster_gene_stats <- list()
for (cluster in levels(breast_cancer_patients_tumor_cells)) {
  tumor_cluster_markers <- tumor_markers_data %>%
    dplyr::filter(cluster == !!cluster)
  
  # Calculate gene counts and save them in a list
  cluster_gene_stats[[cluster]] <- list(
    num_upreg_genes = tumor_cluster_markers %>%
      dplyr::filter(avg_log2FC > 0, p_val < 0.05) %>%
      nrow(),
    num_downreg_genes = tumor_cluster_markers %>%
      dplyr::filter(avg_log2FC < 0, p_val < 0.05) %>%
      nrow()
  )
}

# Lists to save plots and tibbles
GSEA_plots <- list()
GSEA_tibbles <- list()

GSEA_to_plot <- list()
# GSEA plots with results
for (cluster in names(GSEA_results)) {
  gsea <- GSEA_results[[cluster]]
  # If there are results
  if (nrow(gsea@result) > 0) {
    GSEA_to_plot[[cluster]] <- GSEA_results[[cluster]]
  }
}
# Print the names of the clusters with GSEA results
print(names(GSEA_to_plot))

# Simplify values for the GSEA plots
GSEA_plot_simply_cutoff <- c(
  "4" = 0.5,
  "5" = 0.5,
  "8" = 1)
# Create plots and tibbles
# Do not plot if no pathways have been found
for (cluster in names(GSEA_to_plot)) {
  gsea <- GSEA_to_plot[[cluster]]
  # Simplify GSEA results by grouping together or eliminating terms that are very similar or redundant
  gsea_simplified <- clusterProfiler::simplify(gsea, cutoff = GSEA_plot_simply_cutoff[[cluster]])
  gene_stats <- cluster_gene_stats[[cluster]]
  num_upreg_genes <- gene_stats$num_upreg_genes
  num_downreg_genes <- gene_stats$num_downreg_genes
  
  # Prepare plot labels
  GSEAlabels <- labs(
    title = paste("Significant Pathways in Tumor Cluster", cluster), 
    subtitle = "by Gene Set Enrichment Analysis",
    caption = paste0("Based on ", num_upreg_genes, " up-regulated genes and ", num_downreg_genes, " down-regulated genes.")
  )
  # Prepare plot aesthetics
  GSEAtheme <- theme(
    plot.title = element_text(hjust = 0.5, size = 20),
    plot.subtitle = element_text(hjust = 0.5, size = 15),
    axis.text.x = element_text(angle = 0, size = 10),
    axis.text.y = element_text(angle = 0, size = 6)
  ) 
  # Make the GSEA plot
  GSEADotPlot <- dotplot(gsea_simplified, showCategory = 25) +
    GSEAlabels + labs(x = "Gene Ratio", y = "Biological Pathway") +
    GSEAtheme
  
  # Save the plot and tibble
  GSEA_plots[[glue("GSEA Tumor cluster {cluster}")]] <- GSEADotPlot
  GSEA_tibbles[[glue("GSEA Tumor cluster {cluster}")]] <- as_tibble(gsea_simplified@result)
}
```

```{r}
#| label: gsea-plots

# Display the GSEA plots
print(GSEA_plots)
```

```{r}
#| label: gsea-tibbles

# Display the GSEA tibbles
print(GSEA_tibbles)
```

```{r}
#| label: gsea-save
#| eval: false

# Save the GSEA plots
save_data(GSEA_plots, here(images_dir, "GSEA plots"))
# Save the GSEA tibbles
save_data(GSEA_tibbles, here(images_dir, "GSEA tables"))
# Save the GSEA results
saveRDS(GSEA_results, here(objects_dir, "GSEA_results.rds"))
```


## Merge

Merge normal and tumor subclusters

```{r}
#| label: merge-cells-metadata

## Copy tumor clusters
# Find common cells between tumor and original Seurat objects
common_tumor_cells <- dplyr::intersect(rownames(breast_cancer_patients_filt_cells@meta.data), 
                          rownames(breast_cancer_patients_tumor_cells@meta.data))
# Copy the metadata for the tumor cells
breast_cancer_patients_filt_cells@meta.data[common_tumor_cells, chosen_tumor_cluster] <- 
  breast_cancer_patients_tumor_cells@meta.data[common_tumor_cells, chosen_tumor_cluster]

# Name of metadata column with tumor subclusters
cell_subcluster_col <- "cell_subcluster"
# Merge the insitutype phenotyping with the tumor clusters
breast_cancer_patients_filt_cells@meta.data %<>%
  mutate("{cell_subcluster_col}" := if_else(
    get(col_ist_ann) != "Tumor",
    get(col_ist_ann),
    glue("Tumor {get(chosen_tumor_cluster)}")
))
print(glue("Number of cell phenotypes (Insitutype + Tumor clusters):
           {length(unique(breast_cancer_patients_filt_cells@meta.data[[cell_subcluster_col]]))}"))
```

## Spatial plots of clusters

Plot the spatial distribution of the cell types and label them according to the normal/tumor clusters where they belong.

```{r}
#| label: spatial-clusters-plots

# Count the number of tumor clusters
num_tumor_clusters <- length(levels(breast_cancer_patients_tumor_cells@meta.data[[chosen_tumor_cluster]]))
# Create a gray scale for the tumor clusters
tumor_clusters_colors <- gray.colors(12, start = 0.2, end = 0.9)
# Create the color palette for the niches
cells_all_phenotypes_color_palette <- generate_colors_lookup_table(
  breast_cancer_patients_filt_cells,
  cluster_column_name = cell_subcluster_col,
  known_clusters_colors = cell_type_colors,
  color_palette = tumor_clusters_colors)
# Create the plots with the cell types for every stamp
cell_types_stamps_plots <- generate_spatial_plots(
  breast_cancer_patients_filt_cells,
  cluster_var = cell_subcluster_col,
  cluster_name = "Cell types with tumor subclusters",
  legend_fill = "Cell types",
  color_lookup_table = cells_all_phenotypes_color_palette)
# Display the plots
print(cell_types_stamps_plots)
```

```{r}
#| eval: false

# Save the plots
save_data(cell_types_stamps_plots, here(images_dir, "Stamps_with_clusters"))
```

## Spatial niches

### Build niches

```{r}
#| label: build-spatial-niches

# To build the niche assay, Seurat uses only the spatial images and the cell phenotypes (a column from the metadata)
# Number of niche to calculate
niches_nums <- c(6, 9)
# Build the niche assays
for (num in niches_nums) {
  # Print the current number of niches being calculated
  print(glue("Calculating {num} niches"))
  # Build the niche assay
  breast_cancer_patients_filt_cells <- BuildNicheAssay(
    object = breast_cancer_patients_filt_cells,
    fov = "LU001FFP03",
    group.by = col_ist_ann,
    assay = glue("niches{num}"),
    cluster.name = glue("niches_{num}"),
    # Number of niches to find, default is 4
    niches.k = num,
    # Number of neighbors to consider, default is 20
    # Very small neighborhoods produce sparse and noisy data
    # Very large neighborhoods become inaccurate representations of a cell’s 3D surroundings:
    # the area of your circular neighborhood increases with the square of the radius,
    # but the volume of the corresponding (unobserved) 3D tissue 
    # region increases with the cube of the radius.
    # This means that the larger the radius, the less of your 3D neighborhood falls in
    # the narrow tissue slide you’ve assayed, and the more it consists of unseen cells
    # increasingly far away in the Z-dimension.
    neighbors.k = 30
  )
}
```

```{r}
#| eval: false

# Save the object
saveRDS(breast_cancer_patients_filt_cells, here(objects_dir, glue("breast_cancer_patients_filt_cells_niches.rds")))
```

### Spatial plots of niches

```{r}
#| label: spatial-niches-plots

# Metadata column with the highest number of niches
col_highest_niches_num <- glue("niches_{niches_nums[length(niches_nums)]}")
# Number of niches to plot
niches_plot <- niches_nums[1]
# Metadata column with the niches to plot
col_niches_plot <- glue("niches_{niches_plot}")

# Create the color palette for the niches
niches_color_palette <- generate_colors_lookup_table(
  breast_cancer_patients_filt_cells,
  cluster_column_name = col_highest_niches_num,
  color_palette = brewer.pal(12, name = "Set3"))
# Create the plots with the niches for every stamp
niches_stamps_plots <- generate_spatial_plots(
  breast_cancer_patients_filt_cells,
  cluster_var = col_niches_plot,
  cluster_name = "Seurat niches",
  legend_fill = "Niches",
  color_lookup_table = niches_color_palette)
# Display the plots
print(niches_stamps_plots)
```

```{r}
#| eval: false

# Save the plots
save_data(niches_stamps_plots, here(images_dir, glue("Stamps_with_{niches_plot}_niches")))
```

### Statistics about niches

```{r}
#| label: niches-statistics-calc

# Create list to save data
niches_statistics_calc <- list()

# Count and calculate percentages of cell types inside every niche
# The percentages of the various cells types in a niches adds up to 100%
cell_type_counts <- breast_cancer_patients_filt_cells@meta.data %>%
  group_by(!!sym(col_niches_plot), !!sym(cell_subcluster_col)) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count / sum(count)) * 100) %>%
  arrange(.by_group = TRUE)
# Print the cell type counts and percentages
niches_statistics_calc[["cell_type_counts"]] <- cell_type_counts

# Get the list of unique niches
niches <- sort(unique(breast_cancer_patients_filt_cells@meta.data[[col_niches_plot]]))
# Print the niches
print(sort(niches))

# Create list to save niches data
niches_data <- list()

# Loop through each niche and calculate the data for the plot
for (niche in niches) {
  
  # Set the cutoff value for the percentage
  niche_cell_type_cutoff <- 2
  # Filter out cells in other niches and group the cells types below the cutoff together
  niche_stat <- cell_type_counts %>%
    dplyr::filter(!!sym(col_niches_plot) == niche) %>%
    dplyr::mutate(
      !!sym(cell_subcluster_col) := ifelse(
        percentage >= niche_cell_type_cutoff,
        !!sym(cell_subcluster_col),
        "Others")
    ) %>%
    dplyr::group_by(!!sym(cell_subcluster_col), !!sym(col_niches_plot)) %>%
    dplyr::summarize(
      percentage = sum(percentage, na.rm = TRUE),
      count = sum(count, na.rm = TRUE),
      .groups = "drop"
    )
  niches_data[[glue("Niche_{niche}_statistics")]] <- niche_stat
}
# Add niches data to print list
niches_statistics_calc <- c(niches_statistics_calc, niches_data)

print(niches_statistics_calc)
```

```{r}
#| label: niches-statistics-plots

# Create list to save data
niches_statistics_plots <- list()

# Loop through each niche and create a bar plot
for (niche in niches) {
  
  # Extract niche data
  niche_data <- niches_data[[niche]]

  # Create the bar plot
  niche_barplot <- niche_data %>%
    ggplot(aes(
      x = !!sym(cell_subcluster_col),
      y = percentage,
      fill = !!sym(cell_subcluster_col)
    )) +
    geom_bar(stat = "identity") +
    geom_text(
      aes(label = count),
      vjust = -0.3,
      color = "black",
      size = 3.5
    ) +
    labs(
      title = paste("Niche:", niche),
      subtitle = "Cell Type Distribution",
      caption = glue(
        "Cutoff value: {niche_cell_type_cutoff}%, the cells types with a percentage below the cutoff are grouped together as 'Others'.
        The percentage of each cell type represents its proportion within the niche, with all percentages summing to 100%.
        The count number above the bars represents the number of cells of each type."
      ),
      x = "Cell Type",
      y = "Percentage (%)"
    ) +
    # Make space for the count number above the bars
    expand_limits(y = max(niche_data$percentage) * 1.04) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          # Move caption to the left
          plot.caption = element_text(hjust = 0)) +
    scale_fill_manual(values = cells_all_phenotypes_color_palette) +
    NoLegend()

  # Add the plot to the list
  niches_statistics_plots[[glue::glue("Niche_{niche}_barplot")]] <- niche_barplot
}

# Display all niches bar plots
print(niches_statistics_plots)
```

```{r}
#| label: niches-patients-statistics

# Create list to save data
niches_patient_data <- list()

# Count and calculate percentage of cell types per niche
niches_patient_counts <- breast_cancer_patients_filt_cells@meta.data %>%
  mutate("{col_niches_plot}" := factor(!!sym(col_niches_plot), levels = sort(unique(!!sym(col_niches_plot)))),
         Patient.ID = factor(Patient.ID)) %>%
  group_by(Patient.ID, !!sym(col_niches_plot)) %>%
  summarise(count = n()) %>%
  mutate(percentage = (count / sum(count)) * 100) %>%
  arrange(Patient.ID, .by_group = TRUE)
# Add to list
niches_patient_data[["niches_patient_counts"]] <- niches_patient_counts

# Create the bar plot
niches_patient_dotplot <- ggplot(niches_patient_counts,
                                 aes(x = Patient.ID, y = percentage, color = !!sym(col_niches_plot))) +
  geom_rect(data = unique(niches_patient_counts["Patient.ID"]),
            aes(xmin = as.numeric(Patient.ID) - 0.4,
                xmax = as.numeric(Patient.ID) + 0.4,
                ymin = -Inf, ymax = Inf),
            fill = "grey90", alpha = 0.3, inherit.aes = FALSE) +
  geom_point(size = 2, position = position_dodge(width = 0.4)) +
  labs(title = paste("Niches distribution across patients"),
       x = "Patient",
       y = "Percentage (%)") +
  guides(color = guide_legend(title = "Niche")) +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1)) +
  scale_color_manual(values = niches_color_palette)
# Add to list
niches_patient_data[["niches_patient_dotplot"]] <- niches_patient_dotplot

# Print the list
print(niches_patient_data)
```

```{r}
#| eval: false

# Folder name
stat_niches_dir <- glue("Statistics_{niches_plot}_niches")
# Save the plots
save_data(niches_statistics_calc, here(images_dir, stat_niches_dir))
save_data(niches_statistics_plots, here(images_dir, stat_niches_dir))
save_data(niches_patient_data, here(images_dir, stat_niches_dir))
```

## CellChat

```{r}
#| label: cellchat

data.input = Seurat::GetAssayData(breast_cancer_patients_analyze, layer = "data", assay = "SCT")
spatial.locs = Seurat::GetTissueCoordinates(
  object = breast_cancer_patients_analyze,
  image = "LU001FFP03",
) %>%
# Set the rownames equal to the cell names and remove the cell column
  tibble::column_to_rownames(var = "cell")

# For CosMx data, the spatial coordinates are in pixels and the conversion factor of converting spatial coordinates from Pixels to Micrometers is 0.18. Because CosMx does not include the uniform cell size like 10X Visium and Slide-seq, users can compute the minimum cell centroid-to-centroid distance via computeCellDistance and use its half value as the tolerance factor. Of note, CellChat does not need an accurate tolerance factor, which is used for determining whether considering the cell-pair as spatially proximal if their distance is greater than interaction.range but smaller than “interaction.range + tol”.

conversion.factor = 0.18
d = computeCellDistance(spatial.locs)
spot.size = min(d)*conversion.factor # converting the distance in Pixels to Micrometers
spatial.factors = data.frame(ratio = conversion.factor, tol = spot.size/2)

cellchat <- createCellChat(
  object = data.input,
  meta = breast_cancer_patients_filt_cells@meta.data,
  group.by = col_ist_ann,
  datatype = "spatial",
  coordinates = spatial.locs,
  spatial.factors = spatial.factors)

CellChatDB <- CellChatDB.human
showDatabaseCategory(CellChatDB)
```